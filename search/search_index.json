{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#course-information","title":"Course Information","text":""},{"location":"#schedule","title":"Schedule","text":"Week Date Topic Test 1. Sept 15 Requirements. ROS introduction. Setup the development environment. - 2. Sept 22 Setup the development environment. Linux principles. ROS principles. Running examples. ROS package. Basics of ROS communication, implementation of publisher and subscriber. Project topic announcements. 4. Oct 6 Python principles. Practicing ROS communication, solving examples. - 5. Oct 13 Principles of robotics. Programming a da Vinci surgical robot in simulated environment I. - 6. Oct 20 Principles of robotics. Programming a da Vinci surgical robot in simulated environment II. - 7. Oct 27 Versioning, Git. Project labor I. Test 1 8. Nov 3 ROS 2 Launch, Param, Bag - 9. Nov 10 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space I. - 10. Nov 17 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space II. - 11. Nov 24 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space III. - 12. Dec 1 Project labor II. - 13. Dec 8 - Test 2 14. Dec 15 Project presentations. Test retake 14+1. Dec 19 (Tue) - Mid-term replacement <p>Warning</p> <p>The schedule may change during the semester!</p>"},{"location":"#course-requirements","title":"Course Requirements","text":""},{"location":"#project","title":"Project","text":"<ul> <li>Proved to be the student's own work</li> <li>Running results valid output</li> <li>Grading: completeness of the soultion, proper ROS communication, proper structure of the program, quality of implementation, documentation</li> </ul>"},{"location":"#grading","title":"Grading","text":"<p>Personal attendance on the classes is mandatory (min 70%).</p> <p>To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again.</p> <p>Grade</p> <p>\\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) </p>"},{"location":"#course-supervisor","title":"Course Supervisor","text":"<p>Dr. P\u00e9ter Galambos   peter.galambos@irob.uni-obuda.hu</p>"},{"location":"#teachers","title":"Teachers","text":"<p>Tam\u00e1s Levendovics  tamas.levendovics@irob.uni-obuda.hu</p> <p>Borsa D\u00e9t\u00e1r   detar.borsa@gmail.com</p>"},{"location":"#antal-bejczy-center-for-intelligent-robotics-barkirob","title":"Antal Bejczy Center for Intelligent Robotics (BARK/IROB)","text":"<p>https://irob.uni-obuda.hu</p>"},{"location":"#irob-saf","title":"irob-saf","text":"<p>(iRob Surgical Automation Framework)</p> <p>https://github.com/ABC-iRobotics/irob-saf</p>"},{"location":"#platypous","title":"PlatypOUs","text":"<p>https://github.com/ABC-iRobotics/PlatypOUs-Mobile-Robot-Platform</p>"},{"location":"01_intro/","title":"01. Introduction","text":""},{"location":"01_intro/#robot-operating-system-ros-introduction","title":"Robot Operating System (ROS) introduction","text":""},{"location":"01_intro/#the-definition-of-robot","title":"The definition of robot","text":"<ul> <li>Joseph Engelberger, pioneer in industrial robotics: \"I can't define a robot, but I know one when I see one.\"</li> <li>Wikipedia: \"A robot is a machine\u2014especially one programmable by a computer\u2014 capable of carrying out a complex series of actions automatically. Robots can be guided by an external control device or the control may be embedded within. Robots may be constructed on the lines of human form, but most robots are machines designed to perform a task with no regard to their aesthetics.\"</li> <li>ISO 8373:2012 Robots and robotic devices \u2013 Vocabulary, FDIS 2012: \"A robot is an actuated mechanism programmable in two or more axes with a degree of autonomy, moving within its environment, to perform intended tasks.\"</li> <li>Rodney Brooks, Founder and CTO, Rethink Robotics: \"A robot is some sort of device, wich has sensors those sensors the world, does some sort of computation, decides on an action, and then does that action based on the sensory input, which makes some change out in the world, outside its body. Comment: the part \"make some change outside its body\" discriminates a washing machine from e.g. a Roomba.\"</li> <li>Tam\u00e1s Haidegger, Encyclopedia of Robotics: \"A robot is a complex mechatronic system enabled with electronics, sensors, actuators and software, executing tasks with a certain degree of autonomy. It may be pre-programmed, teleoperated or carrying out computations to make decisions.\"</li> </ul>"},{"location":"01_intro/#what-is-ros","title":"What is ROS?","text":"<ul> <li>Open-source, robotics themed middleware</li> <li>Modularity, reusability (drivers, algorithms, libraries, ...)</li> <li>Hardware abstraction, ROS API</li> <li>C++ \u00e9s Python support</li> <li>Ubuntu Linux (except ROS 2)</li> <li>Great community</li> </ul>"},{"location":"01_intro/#history","title":"History","text":"<ul> <li>Mid 2000s, Stanford: robotics themed, flexible, dynamic framework for prototype development</li> <li>2007, Willow Garage: incubation, the core of ROS under BSD license</li> <li>Spread in robotics reserach, PR2</li> <li>2012: Industrial robotics, ROS-Industrial</li> <li>2017: ROS 2</li> </ul>"},{"location":"01_intro/#development-system-build-homework","title":"Development system build -- homework","text":"<p>Recommended environment:</p> <ul> <li>Ubuntu 22.04</li> <li>ROS2 Humble</li> <li>IDE: QtCreator</li> </ul>"},{"location":"01_intro/#ros-2-humble-hawksbill","title":"ROS 2 Humble Hawksbill","text":"<p>Setup locale.</p> <pre><code>```bash\nlocale  # check for UTF-8\n\nsudo apt update &amp;&amp; sudo apt install locales\nsudo locale-gen en_US en_US.UTF-8\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nexport LANG=en_US.UTF-8\n\nlocale  # verify settings\n```\n\n---\n</code></pre> <ol> <li> <p>ROS 2 Humble install</p> <pre><code>sudo apt install software-properties-common\nsudo add-apt-repository universe\nsudo apt update &amp;&amp; sudo apt install curl -y\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\nsudo apt update\nsudo apt upgrade\nsudo apt install ros-humble-desktop\nsudo apt install ros-dev-tools\n</code></pre> </li> <li> <p>Test the new ROS 2 install:</p> <pre><code>source /opt/ros/humble/setup.bash\nros2 run demo_nodes_py talker\n</code></pre> </li> <li> <p>The <code>source</code> command is responsible for setting the environment variables, which must be specified each time a new terminal window is opened. This command can be inserted at the end of the <code>~/.bashrc</code> file, which is run every time a terminal window is opened, so you don't have to type it every time (ROS 2 will be the default):</p> <pre><code>echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre> </li> </ol>"},{"location":"01_intro/#tovabbi-csomagok","title":"Tov\u00e1bbi csomagok","text":"<ol> <li> <p>We will also need the following packages during the semester, so these should be installed as well:</p> <pre><code>sudo apt install libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev python3-osrf-pycommon libasound2-dev libgl1-mesa-dev xorg-dev python3-vcstool python3-colcon-common-extensions python3-pykdl libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev libbluetooth-dev ros-humble-joint-state-publisher* ros-humble-xacro gfortran-9\n</code></pre> </li> </ol>"},{"location":"01_intro/#ide","title":"IDE","text":"<ol> <li> <p>QtCreator</p> <p>Currently, one of the most widely used IDEs for developing ROS packages is QtCreator, for which a ROS plugin has been developed. The installer is available at the link below. You should use the \"18.04 offline installer\", it also works on Ubuntu 22.04.</p> <p>https://ros-qtc-plugin.readthedocs.io/en/latest/_source/How-to-Install-Users.html</p> <p>Once downloaded, the IDE can be installed using the command below (it is important to put <code>cd</code> in the download location):</p> <pre><code>chmod +x qtcreator-ros-bionic-latest-offline-installer.run\nsudo ./qtcreator-ros-bionic-latest-offline-installer.run\n</code></pre> <p>When the installer asks you where to install it, change it to e.g. <code>/home/&lt;USER&gt;/QtCreator</code>. If you put it in root, you will not be able to run it. After installation, look for `Qt Creator (4.9.2)'.</p> </li> <li> <p>CLion</p> <p>CLion has a high level of ROS integration, and its use is most recommended for this course. A free student license can be obtained at https://www.jetbrains.com/community/education/#students</p> <p>After installation, browse to the file <code>/var/lib/snapd/desktop/applications/clion_clion.desktop</code>. Copy the appropriate line here so that the IDE will use the environment set by the terminal:</p> <pre><code>Exec=bash -i -c \"/snap/bin/clion\" %f\n</code></pre> </li> <li> <p>Visual Studio</p> <p>Microsoft Visual Studio also supports source code for ROS, this IDE can also be used during the semester.</p> </li> </ol> <p>Suggestion</p> <p>Install Terminator terminal emulator: <pre><code>sudo apt update\nsudo apt install terminator\n</code></pre></p>"},{"location":"01_intro/#links","title":"Links","text":"<ul> <li>https://www.ros.org/</li> <li>ROS 2 Humble installation</li> <li>QtCreator + ROS plugin</li> <li>IROB virtual tour</li> </ul>"},{"location":"02_linux_ros_principles/","title":"02. Linux, ROS introduction","text":""},{"location":"02_linux_ros_principles/#lecture","title":"Lecture","text":""},{"location":"02_linux_ros_principles/#linux-principles","title":"Linux principles","text":"<ul> <li>(Was) the only OS supported by ROS</li> <li>Security</li> <li>Efficieny</li> <li>Open-source</li> <li>Community support</li> <li>User freedom</li> <li>Distributions: Ubuntu, Linux Mint, Debian, etc.</li> <li>Terminal usage more dominant</li> </ul> <p>Suggestion</p> <p>Install Terminator terminal emulator: <pre><code>sudo apt update\nsudo apt install terminator\n</code></pre></p>"},{"location":"02_linux_ros_principles/#linux-commands","title":"Linux commands","text":"<p>See some basic commands below:</p> <ul> <li>Run as administrator with <code>sudo</code></li> <li>Manual of command <code>man</code>, e.g. <code>man cp</code></li> <li>Package management <code>apt</code>, e.g. <code>apt update</code>, <code>apt install</code></li> <li>Navigation <code>cd</code></li> <li>List directory contents <code>ls</code></li> <li>Create file <code>touch</code></li> <li>Copy file <code>cp</code></li> <li>Move file <code>mv</code></li> <li>Remove file <code>rm</code></li> <li>Make directory <code>mkdir</code></li> <li>Remove directory <code>rmdir</code></li> <li>Make a file executable <code>chmod +x &lt;filename&gt;</code></li> <li>Safe restart: Crtl + Alt + PrtScr + REISUB</li> <li>If not sure, just google the command</li> </ul>"},{"location":"02_linux_ros_principles/#ros-1-ros-2","title":"ROS 1 \u2192 ROS 2","text":"<ul> <li>ROS 2 was rewritten from scratch</li> <li>More modular architecture</li> <li>Improved support for real-time systems</li> <li>Support for multiple communication protocols</li> <li>Better interoperability with other robotic systems</li> <li>Focus on standardization and industry collaboration</li> <li>No ROS Master</li> <li>No Devel space</li> <li><code>rclpy</code>, <code>rclcpp</code></li> <li>More structured code (<code>Node</code> class)</li> <li>Different build system</li> <li>Platforms: Windows, OS X, Linux</li> </ul>"},{"location":"02_linux_ros_principles/#ros-principles","title":"ROS principles","text":""},{"location":"02_linux_ros_principles/#ros-workspace","title":"ROS workspace","text":"<p>Colcon workspace</p> <p>A folder where packages are modified, built, and installed.</p> <p></p> <ul> <li>Source space:<ul> <li>Source code of colcon packages</li> <li>Space where you can extract/checkout/clone source code for the packages you want to build</li> </ul> </li> <li>Build space<ul> <li>Colcon is invoked here to build packages</li> <li>Colcon and CMake keep intermediate files here</li> </ul> </li> <li>Install space:<ul> <li>Each package will be installed here; by default each package will be installed into a separate subdirectory</li> </ul> </li> <li>Log space:<ul> <li>Contains various logging information about each colcon invocation</li> </ul> </li> </ul> <p>ROS package principle</p> <p>Enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software.</p> <p>ROS dependencies</p> <p>After cloning a new package, use the following command to install depenencies: <pre><code>rosdep install --from-paths src --ignore-src -r -y\n</code></pre></p>"},{"location":"02_linux_ros_principles/#ros-package","title":"ROS package","text":"<ul> <li>Main unit to organize software in ROS</li> <li>Buildable and redistributable unit of ROS code</li> <li>Consists of (in the case of Python packages):<ul> <li><code>package.xml</code> file containing meta information about the package<ul> <li>name</li> <li>version</li> <li>description</li> <li>dependencies</li> <li>etc.</li> </ul> </li> <li><code>setup.py</code> containing instructions for how to install the package</li> <li><code>setup.cfg</code> is required when a package has executables, so ros2 run can find them</li> <li><code>/&lt;package_name&gt;</code> - a directory with the same name as your package, used by ROS 2 tools to find your package, contains <code>__init__.py</code></li> <li>Anything else</li> </ul> </li> <li><code>ros2 run turtlesim turtlesim_node</code></li> </ul> <p>CMake</p> <p>For CMake packages (C++), the package contents will be different.</p> <p></p>"},{"location":"02_linux_ros_principles/#ros-node","title":"ROS node","text":"<ul> <li>Executable part of ROS:<ul> <li>python scripts</li> <li>compiled C++ code</li> </ul> </li> <li>A process that performs computation</li> <li>Inter-node communication:<ul> <li>ROS topics (streams)</li> <li>ROS parameter server</li> <li>Remote Procedure Calls (RPC)</li> <li>ROS services</li> <li>ROS actions</li> </ul> </li> <li>Meant to operate at a fine-grained scale</li> <li>Typically, a robot control system consists of many nodes, like:<ul> <li>Trajectory planning</li> <li>Localization</li> <li>Read sensory data</li> <li>Process sensory data</li> <li>Motor control</li> <li>User interface</li> <li>etc.</li> </ul> </li> </ul>"},{"location":"02_linux_ros_principles/#ros-build-system-colcon","title":"ROS build system---Colcon","text":"<ul> <li>System for building software packages in ROS</li> </ul>"},{"location":"02_linux_ros_principles/#environmental-setup-file","title":"Environmental setup file","text":"<ul> <li>setup.bash</li> <li>generated during init process of a new workspace</li> <li>extends shell environment</li> <li>ROS can find any resources that have been installed or built to that location</li> </ul> <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre>"},{"location":"02_linux_ros_principles/#practice","title":"Practice","text":""},{"location":"02_linux_ros_principles/#1-turtlesim","title":"1: Turtlesim","text":"<ol> <li> <p>Start <code>turtlesim_node</code> and <code>turtle_teleop_key</code> nodes with the following commands, in separate terminal windows:</p> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <pre><code>ros2 run turtlesim turtle_teleop_key\n</code></pre> <p>Tip</p> <p>In Terminator, you can further divide the given window with Ctrl-Shift-O, Ctrl-Shift-E key combinations. Ctrl-Shift-W closes the active window.</p> <p>Abort execution</p> <p><code>Ctrl-C</code></p> </li> <li> <p>Running the following ROS commands can provide useful information:</p> <pre><code>ros2 wtf\nros2 node list\nros2 node info /turtlesim\nros2 topic list\nros2 topic info /turtle1/cmd_vel\nros2 interface show geometry_msgs/msg/Twist\nros2 topic echo /turtle1/cmd_vel\n</code></pre> </li> <li> <p>Start <code>rqt_gui</code> with the following command:</p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Display the running nodes and topics in <code>rqt_gui</code>: Plugins \u2192 Introspection \u2192 Node Graph.</p> </li> <li> <p>Publish to the <code>/turtle1/cmd_vel</code> topic also using <code>rqt_gui</code>: Plugins \u2192 Topics \u2192 Message Publisher.</p> </li> </ol> <p></p>"},{"location":"02_linux_ros_principles/#2-ros-2-workspace-creation","title":"2: ROS 2 workspace creation","text":"<ol> <li> <p>Let's create a new ROS2 workspace with the name <code>ros2_ws</code>.</p> <pre><code>mkdir -p ~/ros2_ws/src\n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#3-ros-2-package-creation","title":"3: ROS 2 package creation","text":"<ol> <li> <p>Let's create a new ROS2 package with the name <code>ros2_course</code> and a Hello World.</p> <pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python --node-name hello ros2_course\n</code></pre> <p>Syntax</p> <p><code>ros2 pkg create --build-type ament_python &lt;package_name&gt;</code> </p> </li> <li> <p>Build the workspace.</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\n</code></pre> <p>Symlink</p> <p>The option <code>--symlink-install</code> links the source scripts to the Install space, so we don't have to build again after modification.  </p> </li> <li> <p>Insert the following line at the end of the <code>~/.bashrc</code> file:</p> <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre> <p>Import to QtCreator</p> <p>New file or project \u2192 Other project \u2192 ROS Workspace. Select Colcon as Build System and <code>ros2_ws</code> as Workspace path.  </p> <p>Import to CLion</p> <p>Set the Python interpreter to Python 3.8, <code>/usr/bin/python3</code>. Add the follwong path: <code>/opt/ros/foxy/lib/python3.8/site-packages</code>. Hozzuk l\u00e9tre a <code>compile_commands.json</code> f\u00e1jlt a <code>~/ros2_ws/build</code> k\u00f6nyvt\u00e1rban az al\u00e1bbi tartalommal: <pre><code>[\n]\n</code></pre></p> </li> <li> <p>Test Hello World:</p> <pre><code>ros2 run ros2_course hello \n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#4-implementing-a-publisher-in-python","title":"4: Implementing a Publisher in Python","text":"<ol> <li> <p>Navigate to the <code>ros2_ws/src/ros2_course/ros2_course</code> folder and create the <code>talker.py</code> file with the content below.</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'talker = ros2_course.talker:main',\n</code></pre> </li> </ol> <ol> <li> <p>Build and run the node:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course talker\n</code></pre> </li> <li> <p>Check the output of the node using <code>ros2 topic echo</code> command or <code>rqt_gui</code>.</p> </li> </ol>"},{"location":"02_linux_ros_principles/#5-implementing-a-subscriber-in-python","title":"5: Implementing a Subscriber in Python","text":"<ol> <li> <p>Navigate to the <code>ros2_ws/src/ros2_course/ros2_course</code> folder and create the <code>listener.py</code> file with the content below.</p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\n\nclass MinimalSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard msg: \"%s\"' % msg.data)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'listener = ros2_course.listener:main',\n</code></pre> </li> <li> <p>Build and run both nodes:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course talker\n</code></pre> <pre><code>ros2 run ros2_course listener\n</code></pre> </li> </ol> <ol> <li> <p>Use <code>rqt_gui</code> to display the nodes and topics of the running system: </p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#useful-links","title":"Useful links","text":"<ul> <li>ROS 2 Tutorials</li> <li>What is a ROS 2 package?</li> </ul>"},{"location":"03_python_principles/","title":"03. Python principles, ROS Publisher, ROS Subscriber","text":""},{"location":"03_python_principles/#lecture","title":"Lecture","text":""},{"location":"03_python_principles/#python-principles","title":"Python principles","text":"<ul> <li>Interpreted, high-level programming language</li> <li>Name tribute to the comedy group Monty Python</li> <li>Powerful, still easy to learn, easy to use</li> <li>Readability</li> <li>Whitespace indentation</li> </ul> <ul> <li>Dynamically-typed</li> <li>Garbage colector and reference counting</li> <li>Object oriented programming</li> <li>Used in: AI, web applications, scientific computing, and many other areas</li> <li><code>python3</code></li> </ul>"},{"location":"03_python_principles/#python-syntax","title":"Python syntax","text":"<pre><code>import numpy as np\nimport math\n\nclass A:\n    def __init__(self, name):\n        self.name = name\n\n    def do_something(self):\n        # will do something\n        print(self.name + \" is doing something.\")\n\n    def count_to(self, n):\n        # count to n, tell if the number is odd or even\n        for i in range(n):\n            if i % 2 == 0:\n                print(i + \", it's even.\")\n            else:\n                print(i + \", it's odd.\")\n\n\n\nif __name__ == \"__main__\":\n    a = A(\"John\")\n    a.do_something()\n    a.count_to(10)\n</code></pre>"},{"location":"03_python_principles/#practice","title":"Practice","text":""},{"location":"03_python_principles/#1-move-the-turtle-in-a-straight-line","title":"1: Move the turtle in a straight line","text":"<ol> <li>Let's write a ROS node that moves the turtle forward along a straight line for a given distance.    Let's open a terminal. Let's create <code>~/ros2_ws/src/ros2_course/ros2_course</code>    the <code>turtlesim_controller.py</code> file in our directory:</li> </ol> <pre><code>```bash\ncd ros2_ws/src/ros2_course/ros2_course\ntouch turtlesim_controller.py\n```\n\n\n---\n</code></pre> <ol> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'turtlesim_controller = ros2_course.turtlesim_controller:main',\n</code></pre> </li> </ol> <ol> <li> <p>Copy the skeleton of the program into <code>turtlesim_controller.py</code>:</p> <pre><code>import math\nimport rclpy\nfrom rclpy.node import Node\n\n\nclass TurtlesimController(Node):\n\n    def __init__(self):\n        super().__init__('turtlesim_controller')\n\n\n    def go_straight(self, speed, distance):\n        # Implement straght motion here\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tc = TurtlesimController()\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    tc.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> </ol> <ol> <li> <p>Let's start a <code>turtlesim_node</code> and then examine the topic,    with which we can control. In two separate terminal windows:</p> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <pre><code>ros2 topic list\nros2 topic info /turtle1/cmd_vel\nros2 interface show geometry_msgs/msg/Twist\n</code></pre> <p>Or use<code>rqt_gui</code>:</p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Import the message type <code>geometry_msgs/msg/Twist</code> and create the publisher in <code>turtlesim_controller.py</code>:</p> <pre><code>from geometry_msgs.msg import Twist\n\n#...\n\n# In the constructor:\nself.twist_pub = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)\n</code></pre> </li> <li> <p>We implement the <code>go_straight</code> method. Let's calculate how long it takes,    so that the turtle covers the given distance at the given speed. Publish a message    with which we set the speed, then wait for the calculated time, after that    send another message to reset the speed.    A little help for using the API:</p> <pre><code># Create and publish msg\nvel_msg = Twist()\nif distance &gt; 0:\n    vel_msg.linear.x = speed\nelse:\n    vel_msg.linear.x = -speed\nvel_msg.linear.y = 0.0\nvel_msg.linear.z = 0.0\nvel_msg.angular.x = 0.0\nvel_msg.angular.y = 0.0\nvel_msg.angular.z = 0.0\n\n# Set loop rate\nloop_rate = self.create_rate(100, self.get_clock()) # Hz\n\n# Calculate time\n# T = ...\n\n# Publish first msg and note time when to stop\nself.twist_pub.publish(vel_msg)\n# self.get_logger().info('Turtle started.')\nwhen = self.get_clock().now() + rclpy.time.Duration(seconds=T)\n\n# Publish msg while the calculated time is up\nwhile (some condition...) and rclpy.ok():\n    self.twist_pub.publish(vel_msg)\n    # self.get_logger().info('On its way...')\n    rclpy.spin_once(self)   # loop rate\n\n# turtle arrived, set velocity to 0\nvel_msg.linear.x = 0.0\nself.twist_pub.publish(vel_msg)\n# self.get_logger().info('Arrived to destination.')\n</code></pre> </li> <li> <p>Build and run the node:</p> <pre><code>cd ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course turtlesim_controller\n</code></pre> </li> </ol>"},{"location":"03_python_principles/#2-draw-shapes","title":"2: Draw shapes","text":"<ol> <li> <p>Let's implement the method for turning with a given angle a    in <code>turtlesim_controller.py</code>, similar to straight motion.</p> <pre><code>def turn(self, omega, angle):\n        # Implement rotation here\n</code></pre> </li> <li> <p>Let's implement the straight movement method of drawing a square with a turtle    and using the methods that perform the turn.</p> <pre><code>def draw_square(self, speed, omega, a):\n</code></pre> </li> <li> <p>Let's implement the method of drawing any regular shape with a turtle    using the methods that perform straight movement and turning.</p> <pre><code>def draw_poly(self, speed, omega, N, a):\n</code></pre> </li> </ol>"},{"location":"03_python_principles/#3-go-to-function","title":"3: Go to function","text":"<ol> <li> <p>Let's examine the topic on which <code>turtlesim_node</code> publishes its current position.</p> <pre><code>ros2 topic list\nros2 topic info /turtle1/pose\nros2 interface show turtlesim/msg/Pose\n</code></pre> <p>Or use <code>rqt_gui</code>:  </p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Let's define a subscriber for the topic and write the callback function.</p> <pre><code># Imports\nfrom turtlesim.msg import Pose\n\n    # Constructor\n    self.pose = None\n    self.subscription = self.create_subscription(\n        Pose,\n        '/turtle1/pose',\n        self.cb_pose,\n        10)\n\n    # New method for TurtlesimController\n    def cb_pose(self, msg):\n        self.pose = msg  \n</code></pre> </li> </ol> <ol> <li> <p>We implement the <code>go_to</code> method. Let's test it, call it from main.</p> <pre><code># ...\n\n# Go to method\n    def go_to(self, speed, omega, x, y):\n        # Wait for position to be received\n        loop_rate = self.create_rate(100, self.get_clock()) # Hz\n        while self.pose is None and rclpy.ok():\n            self.get_logger().info('Waiting for pose...')\n            rclpy.spin_once(self)\n\n        # Stuff with atan2\n\n\n# Main\ndef main(args=None):\n    rclpy.init(args=args)\n    tc = TurtlesimController()\n\n    tc.go_to(1.0, 20.0, 2, 8)\n    tc.go_to(1.0, 20.0, 2, 2)\n    tc.go_to(1.0, 20.0, 3, 4)\n    tc.go_to(1.0, 20.0, 6, 2)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    tc.destroy_node()\n    rclpy.shutdown()  \n</code></pre> </li> </ol> <p></p>"},{"location":"03_python_principles/#extra-advanced-go-to","title":"Extra: Advanced go to","text":"<p>Write a go to function that uses a proportional controller.</p>"},{"location":"03_python_principles/#useful-links","title":"Useful links","text":"<ul> <li>For loops in python</li> <li>Some python functions</li> <li>Turtlesim help</li> <li>atan2</li> </ul>"},{"location":"04_da_vinci/","title":"04. Principles of robotics. Programming a da Vinci surgical robot in simulated environment.","text":""},{"location":"04_da_vinci/#lecture","title":"Lecture","text":"<p>Warning</p> <p>Test 1 (ROS principles, publisher, subscriber. Python principles. Principles of robotics.) October 27.</p>"},{"location":"04_da_vinci/#rigid-body-motion","title":"Rigid body motion","text":"<p>Def. Rigid body</p> <p>A rigid body is defined as a body on which the distance between two points remains constant in time regardless of the force applied on it.</p> <ul> <li>Shape and the volume of the rigid bodies are also constant.</li> <li>The pose of a rigid body can be given by the three coordinates of three of its points that do not lie on the same straight line.</li> </ul> <p></p> <ul> <li> <p>The pose of a rigid body can be described in a more expressive way by the three coordinates of one of its points chosen arbitrarily position and the body's orientation.</p> </li> <li> <p>The motion of rigid bodies is composed by two elemental motions: translation and rotation. </p> </li> <li> <p>During translation, all points of the body move along straight, parallel lines. </p> </li> </ul> <p></p> <ul> <li> <p>During rotation, the position of the points of the rotational axis are constant, and the other points of the body move along circles in planes perpendicular to the axis of rotation.</p> </li> <li> <p>The free motion of rigid bodies can always be expressed  as the superposition of a translational motion and a rotation around a single axis.</p> </li> </ul>"},{"location":"04_da_vinci/#3d-transformations","title":"3D transformations","text":"<ul> <li>Position: 3D offset vector  </li> <li> <p>Orientation: 3 x 3 rotation matrix</p> <ul> <li>further orientation representations: Euler-angles, RPY, angle axis, quaternion</li> </ul> </li> <li> <p>Pose: 4 \u00d7 4 (homogenous) transformation matrix</p> </li> <li>Frame: origin, 3 axes, 3 base vectors, right hand rule</li> <li>Homogenous transformation: rotation and translation in one transfromation<ul> <li>e.g., for the rotation \\(\\mathbf{R}\\) and translation \\(\\mathbf{v}\\):</li> </ul> </li> </ul> \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right] = \\left[\\matrix{r_{1,1} &amp; r_{1,2} &amp; r_{1,3} &amp; v_x\\\\r_{2,1} &amp; r_{2,2} &amp; r_{2,3} &amp; v_y\\\\r_{3,1} &amp; r_{3,2} &amp; r_{3,3} &amp; v_z\\\\\\ 0 &amp; 0 &amp; 0 &amp; 1 }\\right] \\] <ul> <li>Homogenous coordinates: <ul> <li>Vector: extended with 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\)</li> <li>Point: extended by 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\)</li> <li>Applying transfomrations is much easier:</li> </ul> </li> </ul> \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] <ul> <li>Degrees of Freedom (DoF): the number of independent parameters.</li> </ul>"},{"location":"04_da_vinci/#principles-of-robotics","title":"Principles of robotics","text":"<ul> <li>Robots are built of: segments (or links) \u00e9s joints</li> <li>Task space (or cartesian space):<ul> <li>3D space around us, where the task, endpoint trajectories, obstacles are defined.</li> <li>TCP (Tool Center Point): Frame fixed to the end effector of the robot.</li> <li>Base frame, world frame</li> </ul> </li> <li>Joint space:<ul> <li>Properties or values regarding the joints.</li> <li>Low-level controller.</li> <li>Joint angles, joint velocities, accelerations, torques....</li> </ul> </li> </ul>"},{"location":"04_da_vinci/#python-libraries","title":"Python libraries","text":""},{"location":"04_da_vinci/#numpy","title":"Numpy","text":"<ul> <li>Python library</li> <li>High dimension arrays and matrices</li> <li>Mathematical functions</li> </ul> <p><pre><code>import numpy as np\n\n# Creating ndarrays\na = np.zeros(3)\na.shape\na.shape=(3,1)\na = np.ones(5)\na = np.empty(10)\nl = np.linspace(5, 10, 6)\nr = np.array([1,2])    # ndarray from python list\nr = np.array([[1,2],[3,4]])\ntype(r)\n\n# Indexing\nl[0]\nl[0:2]\nl[-1]\nr[:,0]\n\n# Operations on ndarrays\nr_sin = np.sin(r)\nnp.max(r)\nnp.min(r)\nnp.sum(r)\nnp.mean(r)\nnp.std(r)\n\nl &lt; 7\nl[l &lt; 7]\nnp.where(l &lt; 7)\n\np = np.linspace(1, 5, 6)\nq = np.linspace(10, 14, 6)\n\ns = p + q\ns = p * q\ns = p * 10\ns = p + 10\ns = p @ q    # dot product\ns = r.T\n</code></pre> If not installed:</p> <pre><code>pip3 install numpy\n</code></pre>"},{"location":"04_da_vinci/#matplotlib","title":"Matplotlib","text":"<ul> <li>Visualization in python</li> <li>Syntax similar to Matlab</li> </ul> <pre><code>import numpy as np\nfrom matplotlib import pyplot as plt\n\nX = np.linspace(-np.pi, np.pi, 256)\nC, S = np.cos(X), np.sin(X)\n\nplt.plot(X, C)\nplt.plot(X, S)\n\nplt.show()\n</code></pre> <p>If not installed:</p> <pre><code>pip3 install matplotlib\n</code></pre>"},{"location":"04_da_vinci/#practice","title":"Practice","text":""},{"location":"04_da_vinci/#1-dvrk-ros-2-install","title":"1. dVRK ROS 2 install","text":"<p>The da Vinci Surgical System is used to perform minimally invasive surgeries by teleoperation. The da Vinci Research Kit (DVRK) is an open-source hardware and software platform, offers, amongst others, reading and writing all the joints of the da Vinci, and also simulators for each arm. The DVRK software can be built as follows.</p> <ol> <li> <p>Clone the dVRK (da Vinci Reserach Kit) using <code>vcs</code> into a new workspace, then build it:</p> <pre><code>mkdir -p ~/dvrk2_ws/src\ncd ~/dvrk2_ws/src                \nvcs import --input https://raw.githubusercontent.com/jhu-dvrk/dvrk_robot_ros2/main/dvrk.vcs --recursive\ncd ~/dvrk2_ws\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release   \nsource ~/dvrk2_ws/install/setup.bash\n</code></pre> </li> <li> <p>Add the following line to the end of the <code>.bashrc</code> file:</p> <pre><code>source ~/dvrk2_ws/install/setup.bash\n</code></pre> </li> <li> <p>Run these commands in separate terminals to launch the simulation. Do not forget to push the Home button in the DVRK console.</p> <pre><code># dVRK main console\nros2 run dvrk_robot dvrk_console_json -j ~/dvrk2_ws/install/sawIntuitiveResearchKitAll/share/sawIntuitiveResearchKit/share/console/console-PSM1_KIN_SIMULATED.json\n</code></pre> <pre><code># ROS 2 joint and robot state publishers\nros2 launch dvrk_model dvrk_state_publisher.launch.py arm:=PSM1\n</code></pre> <pre><code># RViz\nros2 run rviz2 rviz2 -d ~/dvrk2_ws/install/dvrk_model/share/dvrk_model/rviz/PSM1.rviz\n</code></pre> <pre><code># rqt_gui\nros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"04_da_vinci/#2-psm-subscriber","title":"2. PSM subscriber","text":"<ol> <li> <p>Create a new file named <code>psm_grasp.py</code> in the <code>~/ros2_ws/src/ros2_course/ros2_course</code> folder. Add the new entry point to the <code>setup.py</code>, as usually.</p> </li> <li> <p>Check the topics and nodes of the simulator using the commands learned earlier (<code>rostopic list</code>, <code>rosrun rqt_graph rqt_graph</code>, etc.). PSM1 publishes the pose of the TCP and the angle of the jaws into the topics below. Subscribe to these topic in <code>psm_grasp.py</code> and store the current values into variables.</p> <pre><code>/PSM1/measured_cp\n/PSM1/jaw/measured_js\n</code></pre> </li> <li> <p>Build and run the node:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course psm_grasp \n</code></pre> </li> </ol>"},{"location":"04_da_vinci/#3-move-the-tcp-along-a-linear-trajectory","title":"3. Move the TCP along a linear trajectory","text":"<ol> <li> <p>PSM1 expects commands regarding the pose of the TCP and the angle of the jaws from the topics below. Create publishers to these topic in <code>psm_grasp.py</code>.</p> <pre><code>/PSM1/servo_cp\n/PSM1/jaw/servo_jp\n</code></pre> </li> <li> <p>Implement a method that moves the TCP to the desired position along a linear trajectory. Send the gripper to the position (0.0, 0.05, -0.12), leave the orientation as it is. Let the sampling time dt be 0.01s.</p> <pre><code>def move_tcp_to(self, target, v, dt):\n</code></pre> <p>Tip</p> <p>Use the function <code>np.linspace(start, stop, num)</code> to create the array of t values (T). This function can also be used to create the linear trajectory along the axes x, y, z in separate arrays X, Y and Z.</p> </li> <li> <p>Write a method that can open and close the gripper jaws, also along a linear trajectory.</p> <pre><code>def move_jaw_to(self, target, omega, dt):\n</code></pre> <p></p> </li> </ol>"},{"location":"04_da_vinci/#4-dummy-marker","title":"4. Dummy marker","text":"<ol> <li> <p>Write a node that creates a virtual marker that can be grasped publishing<code>visualization_msgs/Marker</code> messages. Create a new file named <code>dummy_marker.py</code> in the <code>~/ros2_ws/src/ros2_course/ros2_course</code> folder. Add it to the <code>setup.py</code>, as usually. Copy the following code into the file <code>dummy_marker.py</code>:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom visualization_msgs.msg import Marker\n\nclass DummyMarker(Node):\n    def __init__(self, position):\n        super().__init__('minimal_publisher')\n        self.position = position\n        self.publisher_ = self.create_publisher(Marker, 'dummy_target_marker', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n        i = 0\n\n    def timer_callback(self):\n        marker = Marker()\n        marker.header.frame_id = 'PSM1_psm_base_link'\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = \"dvrk_viz\"\n        marker.id = self.i\n        marker.type = Marker.SPHERE\n        marker.action = Marker.MODIFY\n        marker.pose.position.x = self.position[0]\n        marker.pose.position.y = self.position[1]\n        marker.pose.position.z = self.position[2]\n        marker.pose.orientation.x = 0.0\n        marker.pose.orientation.y = 0.0\n        marker.pose.orientation.z = 0.0\n        marker.pose.orientation.w = 1.0\n        marker.scale.x = 0.008\n        marker.scale.y = 0.008\n        marker.scale.z = 0.008\n        marker.color.a = 1.0 # Don't forget to set the alpha!\n        marker.color.r = 0.0\n        marker.color.g = 1.0\n        marker.color.b = 0.0;\n\n        self.publisher_.publish(marker)\n        self.i += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    marker_publisher = DummyMarker([-0.05, 0.08, -0.12])\n    rclpy.spin(marker_publisher)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    marker_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Build and run the node. Visualize the marker in RViz.</p> </li> </ol>"},{"location":"04_da_vinci/#5-grasp-the-marker","title":"5. Grasp the marker","text":"<ol> <li> <p>Subscribe to the topic with the marker position <code>dummy_target_publisher</code> the file <code>psm_grasp.py</code>.</p> </li> <li> <p>Implement a method in <code>psm_grasp.py</code> to grasp the generated marker with PSM1.</p> <p>Note</p> <p>Some values tends to stuck in the simulator. Thus, at the beginning of the program, it is a good idea to reset the arm: <pre><code>#Reset the arm\npsm.move_tcp_to([0.0, 0.0, -0.12], 0.01, 0.01)\npsm.move_jaw_to(0.0, 0.1, 0.01)\n</code></pre></p> </li> </ol>"},{"location":"04_da_vinci/#links","title":"Links","text":"<ul> <li>Download and compile dVRK 2</li> <li>Marker examples</li> <li>Numpy vector magnitude</li> <li>Numpy linspace</li> </ul>"},{"location":"05_git/","title":"05. Versioning, Git","text":""},{"location":"05_git/#lecture","title":"Lecture","text":""},{"location":"05_git/#version-control-git","title":"Version control, Git","text":"<ul> <li>Track changes in a set of files</li> <li>Coordinating work among developers</li> <li>Who made what changes and when</li> <li>Revert back at any time</li> <li>Local and remote repos</li> <li>Take snapshots of files by making a commit</li> </ul>"},{"location":"05_git/#install","title":"Install","text":"<pre><code>sudo apt install git\n</code></pre>"},{"location":"05_git/#basic-commands","title":"Basic commands","text":"<pre><code>git init          # Initialize local git repo\ngit add &lt;file&gt;    # Add file/files to staging area\ngit status        # Check status of working tree and staging area\ngit commit -m \"What I've done\"    # Commit changes in index\ngit push          # Push to remote repository\ngit pull          # Pull latest changes from remote repo\ngit branch &lt;new_branch_name&gt;\ngit checkout &lt;branch_name&gt;\ngit merge &lt;branch_name&gt;   # Merge the branch into the current branch\ngit config --global user.name \"Istvan Szabo\"\ngit config --global user.email \"istvan.szabo@gmail.com\"\n</code></pre> <p>Tip</p> <p>Store personal token: <code>git config --global credential.helper store</code></p> <p>Tip</p> <p>Windows and Linux clock issue: <code>timedatectl set-local-rtc 1 --adjust-system-clock</code></p>"},{"location":"05_git/#github","title":"GitHub","text":"<pre><code>git remote\ngit clone &lt;link&gt;   # Copy repo into a new directory\n\n# Add remote to repository:\ngit remote add origin &lt;link&gt;\ngit push -u origin master\n</code></pre> <p>Some alternatives to GitHub</p> <p>GitLab, BitBucket, Launchpad, Phabricator </p>"},{"location":"05_git/#markdown","title":"Markdown","text":"<ul> <li>Markup language, easy to read</li> <li>Text file \u2192 Formatted document</li> <li>Widespread usag, e.g., blogs, forums, documentations, readme files, GitHub </li> <li>Markdown Cheatsheet</li> </ul>"},{"location":"05_git/#gyakorlat","title":"Gyakorlat","text":""},{"location":"05_git/#0-github-repo-letrehozasa","title":"0: GitHub repo l\u00e9trehoz\u00e1sa","text":"<ol> <li>Inicializ\u00e1ljunk egy lok\u00e1lis git repo-t a <code>ros-course</code> package-ben.</li> <li>Regisztr\u00e1ljunk GitHub-ra, majd hozzunk l\u00e9tre egy private repo-t a <code>ros_course</code> package sz\u00e1m\u00e1ra. \u00c1ll\u00edtsuk be a local repo-ban a remote-ot, majd push-oljuk a package tartalm\u00e1t.</li> </ol>"},{"location":"06_roslaunch/","title":"06. ROS 2 Launch, Param, Bag","text":""},{"location":"06_roslaunch/#lecture","title":"Lecture","text":""},{"location":"06_roslaunch/#ros-2-launch","title":"ROS 2 Launch","text":"<ul> <li>Launch multiple nodes</li> <li>Set arguments</li> <li>Monitor running nodes</li> <li>React on changes in the state of nodes</li> <li>Python, XML and YAML file formats</li> </ul>"},{"location":"06_roslaunch/#usage","title":"Usage","text":"<pre><code>    ros2 launch package_name file.launch\n    ros2 launch irob_robot dvrk_server.launch arm_typ:=PSM1\n</code></pre>"},{"location":"06_roslaunch/#ros-2-parameters","title":"ROS 2 Parameters","text":"<ul> <li>Configure nodes at startup or during runtime without changing the code</li> <li>Associated with individual nodes</li> <li>Consists of: key, value, descriptor</li> <li>Available data types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[].</li> <li>Useful command: <code>ros2 param</code></li> </ul>"},{"location":"06_roslaunch/#ros-2-bag","title":"ROS 2 Bag","text":"<ul> <li>Record and playback ROS topics</li> <li>Command line tool</li> <li>API for C++ and Python</li> </ul> <pre><code>    ros2 bag record -o &lt;file_name&gt; &lt;topic_name&gt;\n    ros2 bag record --all\n    ros2 bag info &lt;filename.bag&gt;\n    ros2 bag play &lt;filename.bag&gt;\n</code></pre>"},{"location":"06_roslaunch/#practice","title":"Practice","text":""},{"location":"06_roslaunch/#1-launch-turtlesim-mimic","title":"1: Launch Turtlesim Mimic","text":"<ol> <li> <p>Create the <code>launch</code> folder inside the <code>ros2_course</code> package,    where the launch files can be stored:</p> <pre><code>cd ~/ros2_ws/src/ros2_course\nmkdir launch\n</code></pre> </li> <li> <p>Create the <code>turtlesim_mimic_launch.py</code> file in the new <code>launch</code> folder a    with the following content:</p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='turtlesim',\n            namespace='turtlesim1',\n            executable='turtlesim_node',\n            name='sim'\n        ),\n        Node(\n            package='turtlesim',\n            namespace='turtlesim2',\n            executable='turtlesim_node',\n            name='sim'\n        ),\n        Node(\n            package='turtlesim',\n            executable='mimic',\n            name='mimic',\n            remappings=[\n                ('/input/pose', '/turtlesim1/turtle1/pose'),\n                ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),\n            ]\n        )\n    ])\n</code></pre> </li> <li> <p>Add the followings to the <code>setup.py</code> file:</p> <pre><code>import os\nfrom glob import glob\n\n# ...\n\ndata_files=[\n    ('share/ament_index/resource_index/packages',\n        ['resource/' + package_name]),\n    ('share/' + package_name, ['package.xml']),\n    # Include all launch files.\n    (os.path.join('share', package_name),\n        glob('launch/*launch.[pxy][yma]*'))\n],\n</code></pre> </li> <li> <p>Add the <code>ros2launch</code> dependency to the <code>package.xml</code> file:</p> <pre><code>&lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;\n</code></pre> </li> <li> <p>Build the workspace:</p> <pre><code>cd ros2_ws\ncolcon build --symlink-install\n</code></pre> </li> <li> <p>Launch the launch file:</p> <pre><code>ros2 launch ros2_course turtlesim_mimic_launch.py\n</code></pre> </li> <li> <p>Publish to the topic from the command line, in a new terminal window:</p> <pre><code>ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}\"\n</code></pre> </li> <li> <p>Let's examine the operation of the system using <code>rqt_gui</code>:</p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#2-launch-turtlesim-goto","title":"2: Launch Turtlesim Goto","text":"<ol> <li> <p>Let's make a copy of <code>turtlesim_mimic_launch.py</code>    from a file named <code>turtlesim_controller_launch.py</code>.</p> </li> <li> <p>Add the <code>turtlesim_controller</code> node written in the previous lesson to the launch file.    The turtle to be controlled can be set using <code>namespace</code> or <code>remappings</code>.</p> </li> </ol> <ol> <li> <p>Build the workspace:</p> <pre><code>cd ros2_ws\ncolcon build --symlink-install\n</code></pre> </li> <li> <p>launch the new launch file:</p> <pre><code>ros2 launch ros2_course turtlesim_controller_launch.py\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#3-turtlesim-controller-params","title":"3: Turtlesim controller params","text":"<ol> <li> <p>Modify <code>turtlesim_controller</code> so that the linear velocity and angular velocity.    is adjustable via ROS parameters. API example for parameters:</p> <pre><code>import rclpy\nimport rclpy.node\n\nclass MinimalParam(rclpy.node.Node):\n    def __init__(self):\n        super().__init__('minimal_param_node')\n        # Declare parameter named 'my_parameter' and\n        # set default value to 'world'\n        self.declare_parameter('my_parameter', 'world')\n        self.timer = self.create_timer(1, self.timer_callback)\n\n    def timer_callback(self):\n        my_param = self.get_parameter('my_parameter').get_parameter_value().string_value\n        self.get_logger().info('Hello %s!' % my_param)\n\n\ndef main():\n    rclpy.init()\n    node = MinimalParam()\n    rclpy.spin(node)\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Let's run <code>turtlesim_controller.py</code> using the previously written launch file.    Let's list the parameters.</p> <pre><code>ros2 launch ros2_course turtlesim_controller_launch.py\n</code></pre> <pre><code>ros2 param list\n</code></pre> </li> <li> <p>Change the speed and angular velocity parameters from the command line using the following command:</p> <pre><code>ros2 param set &lt;NODE_NAME&gt; &lt;PARAM_NAME&gt; &lt;NEW_VALUE&gt;\nros2 param set controller speed 100.0\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#4-turtlesim-controller-launch-and-substitutions","title":"4: Turtlesim controller launch and substitutions","text":"<ol> <li> <p>Let's make a copy of <code>turtlesim_controller_launch.py</code> as <code>turtlesim_controller_param_launch.py</code>.    Modify the new launch file based on the example below so that the velocity and angular velocity parameters of the launch    can be specified as file arguments.</p> <pre><code>from launch_ros.actions import Node\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, ExecuteProcess, TimerAction\nfrom launch.conditions import IfCondition\nfrom launch.substitutions import LaunchConfiguration, PythonExpression\n\ndef generate_launch_description():\n\n    turtlesim_ns_launch_arg = DeclareLaunchArgument(\n        'turtlesim_ns',\n        default_value='turtlesim1',\n        description='Namespace for turtle 1'\n    )\n    use_provided_red_launch_arg = DeclareLaunchArgument(\n        'use_provided_red',\n        default_value='False'\n    )\n    new_background_r_launch_arg = DeclareLaunchArgument(\n        'new_background_r',\n        default_value='200'\n    )\n    background_g_launch_arg = DeclareLaunchArgument(\n        'background_g',\n        default_value='100'\n    )\n    background_b_launch_arg = DeclareLaunchArgument(\n        'background_b',\n        default_value='100'\n    )\n\n    turtlesim_ns_value = LaunchConfiguration('turtlesim_ns')\n    use_provided_red_value = LaunchConfiguration('use_provided_red')\n    new_background_r_value = LaunchConfiguration('new_background_r')\n    background_g_value = LaunchConfiguration('background_g')\n    background_b_value = LaunchConfiguration('background_b')\n\n    turtlesim_node = Node(\n        package='turtlesim',\n        namespace=turtlesim_ns_value,\n        executable='turtlesim_node',\n        name='sim',\n        parameters=[{\n            'background_g': background_g_value,\n            'background_b': background_b_value,\n        }]\n    )\n    spawn_turtle = ExecuteProcess(\n        cmd=[[\n            'ros2 service call ',\n            turtlesim_ns,\n            '/spawn ',\n            'turtlesim/srv/Spawn ',\n            '\"{x: 2, y: 2, theta: 0.2}\"'\n        ]],\n        shell=True\n    )\n    change_background_r = ExecuteProcess(\n        cmd=[[\n            'ros2 param set ',\n            turtlesim_ns,\n            '/sim background_r ',\n            '120'\n        ]],\n        shell=True\n    )\n    change_background_r_conditioned = ExecuteProcess(\n        condition=IfCondition(\n            PythonExpression([\n                new_background_r_value,\n                ' == 200',\n                ' and ',\n                use_provided_red\n            ])\n        ),\n        cmd=[[\n            'ros2 param set ',\n            turtlesim_ns_value,\n            '/sim background_r ',\n            new_background_r\n        ]],\n        shell=True\n    )\n\n    return LaunchDescription([\n        turtlesim_ns_launch_arg,\n        use_provided_red_launch_arg,\n        new_background_r_launch_arg,\n        turtlesim_node,\n        spawn_turtle,\n        change_background_r,\n        TimerAction(\n            period=2.0,\n            actions=[change_background_r_conditioned],\n        )\n    ])\n</code></pre> </li> <li> <p>Build the workspace and run <code>turtlesim_controller_param_launch.py</code>:</p> <pre><code>cd ros2_ws\ncolcon build --symlink-install\nros2 launch ros2_course turtlesim_controller_param_launch.py\n</code></pre> </li> <li> <p>Let's list the arguments of the new launch file:</p> <pre><code>ros2 launch ros2_course turtlesim_controller_param_launch.py --show-args\n</code></pre> </li> <li> <p>Run the launch file by setting the arguments:</p> <pre><code>ros2 launch ros2_course turtlesim_controller_param_launch.py speed:=100.0 omega:=60.0\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#5-using-the-above-example-lets-set-the-background-color-also-using-command-line-arguments","title":"5. Using the above example, let's set the background color also using command line argument(s).","text":""},{"location":"06_roslaunch/#5-rosbag","title":"5: Rosbag","text":"<ol> <li> <p>While the program implemented in the previous exercise is running,    record the contents of the topics in a rosbag file.</p> <pre><code>    ros2 bag record --all\n</code></pre> </li> </ol> <p>!!! tip \"Syntax\"    The filename and the topics to record can also be set, e.g.:    <pre><code>ros2 bag record -o turtle_bagfile_1 /turtle1/cmd_vel /turtle1/pose\n</code></pre></p> <ol> <li> <p>Use the following command to query the properties of the bag file:</p> <pre><code>ros2 bag info &lt;PATH_TO_BAGFILE&gt;\n</code></pre> </li> <li> <p>Play back the bag file and plot the <code>pose/x</code> value of one of the turtles on a graph using <code>rqt_gui</code>.</p> <pre><code>ros2 bag info &lt;PATH_TO_BAGFILE&gt;\n</code></pre> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#useful-links","title":"Useful links","text":"<ul> <li>ROS 2 Launch Tutorial</li> <li>ROS 2 Parameters</li> <li>Using ROS 2 parameters in a Class</li> <li>ROS 2 Bag</li> </ul>"},{"location":"07_robotics_principles/","title":"09. Kinematics, inverse kinematics, Programming of a simulated robotic arm","text":"<p>Warning</p> <p>Test 2 on December 8.</p>"},{"location":"07_robotics_principles/#rehearsal","title":"Rehearsal","text":""},{"location":"07_robotics_principles/#3d-transformations","title":"3D transformations","text":"<ul> <li>Position: 3 element offset vector</li> </ul> <ul> <li> <p>Orientation: 3 x 3 rotation matrix</p> <ul> <li>additional orientation representations: Euler angles, RPY, angle axis, quaternion</li> </ul> </li> <li> <p>Pose: 4 \u00d7 4 transformation matrix</p> </li> <li>Coordinate frame: origin, 3 axis, 3 base vector, right-hand rule</li> <li>Homogeneous transformations: rotation and translation together<ul> <li>e.g. \\(\\mathbf{R}\\) for rotation and \\(\\mathbf{v}\\) for translation:</li> </ul> </li> </ul> \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right] = \\left[\\matrix{r_{1,1} &amp; r_{1,2} &amp; r_{1,3} &amp; v_x\\\\r_{2,1} &amp; r_{2,2} &amp; r_{2,3} &amp; v_y\\\\r_{3,1} &amp; r_{3,2} &amp; r_{3,3} &amp; v_z\\\\\\ 0 &amp; 0 &amp; 0 &amp; 1 }\\right] \\] <ul> <li>Homogeneous coordinates:<ul> <li>Vector: add 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\)</li> <li>Point: add 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\)</li> <li>Applying transformations is simpler:</li> </ul> </li> </ul> \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] <ul> <li>Degree of freedom (DoF): number of independent variables (quantities).</li> </ul>"},{"location":"07_robotics_principles/#robotics-basics","title":"Robotics basics","text":"<ul> <li>Robot structure: segments (link) and joints</li> <li>Task space (Cartesian space):<ul> <li>Three-dimensional space where the task, trajectories, obstacles, etc. are defined.</li> <li>TCP (Tool Center Point): coordinate frame fixed to the end effector</li> <li>Base/world frame</li> </ul> </li> <li>Joint space:<ul> <li>Quantities assigned to the robot's joints, which can be interpreted by the robot's low-level control system.</li> <li>Joint angles, velocities, accelerations, torques...</li> </ul> </li> </ul>"},{"location":"07_robotics_principles/#lecture","title":"Lecture","text":""},{"location":"07_robotics_principles/#kinematics-inverse-kinematics","title":"Kinematics, inverse kinematics","text":""},{"location":"07_robotics_principles/#kinematics","title":"Kinematics","text":"<p>Def. Kinematics</p> <p>Calculating the pose of the TCP (or anything else) from the joint coordinates.</p> <ul> <li>Kinematic model<ul> <li>Denavit--Hartenberg (DH) convention</li> <li>URDF (Unified Robotics Description Format, XML-based)</li> </ul> </li> </ul> <p>If the coordinate systems assigned to the segments are \\(base, 1, 2, 3, ..., TCP\\), the transfomrms between adjacent segments \\(i\\) and \\(i+1\\) are \\(T_{i+1,i}(q_{i+1})\\) (which is a function of the angle of the joint between them), the transfomrs between the base frame and TCP can be written as (for a robot with \\(n\\) joints):</p> \\[  T_{TCP,base}(q_1, \\cdots, q_n) = T_{TCP,n-1}(q_{n}) \\cdot T_{n-1,n-2}(q_{n-1}) \\cdots T_{2,1}(q_2) \\cdot T_{1,base}(q_1) \\cdot base  \\]"},{"location":"07_robotics_principles/#inverse-kinematics","title":"Inverse kinematics","text":"<p>Def. Inverse kinematics</p> <p>Calculate the joint coordinates to achieve (desired) TCP (or any other) pose.</p>"},{"location":"07_robotics_principles/#differential-inverse-kinematics","title":"Differential inverse kinematics","text":"<p>Def. Differential inverse kinematics</p> <p>Which change in the joint coordinates achieves the desired small change in the TCP pose (rotation and translation).</p> <ul> <li> <p>Jacobi matrix (Jacobian): a matrix of first-order partial derivatives of a vector-valued function.</p> \\[ \\mathbf{J} = \\left[\\matrix{\\frac{\\partial x_1}{\\partial q_1} &amp; \\frac{\\partial x_1}{\\partial q_2} &amp;\\frac{\\partial x_1}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_1}{\\partial q_n} \\\\ \\frac{\\partial x_2}{\\partial q_1} &amp; \\frac{\\partial x_2}{\\partial q_2} &amp;\\frac{\\partial x_2} {\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_2}{\\partial q_n} \\\\ \\frac{\\partial x_3}{\\partial q_1} &amp; \\frac{\\partial x_3}{\\partial q_2} &amp;\\frac{\\partial x_3}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_3}{\\partial q_n} \\\\ \\vdots &amp;\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\ \\frac{\\partial x_m}{\\partial q_1} &amp; \\frac{\\partial x_m}{\\partial q_2} &amp;\\frac{\\partial x_m}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_m}{\\partial q_n} \\\\}\\right] \\] </li> <li> <p>Jacobi matrix significance in robotics: gives the relationship between joint velocities and TCP velocity.</p> \\[ \\left[\\matrix{\\mathbf{v} \\\\ \\mathbf{\\omega}}\\right] =\\mathbf{J}(\\mathbf{q})\\cdot \\mathbf{\\dot{q}} \\] <p>,where \\(\\mathbf{v}\\) is the linear velocity of the TCP, \\(\\mathbf{\\omega}\\) is the angular velocity of the TCP, and \\(\\mathbf{q}\\) is the configuration of the robot.</p> </li> </ul> <p>Def. Configuration</p> <p>The vector or array containing the current joint angles of the robot.</p>"},{"location":"07_robotics_principles/#inverse-kinematics-using-jacobian-inverse","title":"Inverse kinematics using Jacobian inverse","text":"<ol> <li>Calculate the difference between the desired and the current position: \\(\\Delta\\mathbf{r} = \\mathbf{r}_{desired} - \\mathbf{r}_0\\)</li> <li>Calculate the difference in rotations: \\(\\Delta\\mathbf{R} = \\mathbf{R}_{desired}\\mathbf{R}_{0}^{T}\\), then convert to axis angle representation \\((\\mathbf{t},\\phi)\\)</li> <li>Compute \\(\\Delta\\mathbf{ q}=\\mathbf{J}^{-1}(\\mathbf{q_0})\\cdot \\left[\\matrix{k_1 \\cdot \\Delta\\mathbf{r} \\\\ k_2 \\cdot \\mathbf{\\omega}}\\right]\\), where the inverse can be pseudo-inverse or transposed</li> <li>\\(\\mathbf{q}_{better} = \\mathbf{q}_{0} + \\Delta\\mathbf{q}\\)</li> </ol>"},{"location":"07_robotics_principles/#exercise","title":"Exercise","text":""},{"location":"07_robotics_principles/#1-ur-install","title":"1: UR install","text":"<ol> <li> <p>Install the dependencies and the UR driver.</p> <p></p> <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt-get install ros-humble-ur python3-pip\npip3 install kinpy\n</code></pre> <p>Tip</p> <p>Also download the source of the <code>kinpy</code> package, it might be useful for understanding the API: https://pypi.org/project/kinpy/</p> </li> <li> <p>Download the zip containing your source files from Moodle (<code>ur_ros2_course.zip</code>). Copy the <code>view_ur.launch.py</code> file to the <code>ros2_course/launch</code> folder, and <code>topic_latcher.py</code> to <code>ros2_course/ros2_course</code>. Add the following lines to <code>setup.py</code> (launch and entry point):</p> <pre><code>import os\nfrom glob import glob\n\n# ...\n\ndata_files=[\n    ('share/ament_index/resource_index/packages',\n        ['resource/' + package_name]),\n    ('share/' + package_name, ['package.xml']),\n    # Include all launch files.\n    (os.path.join('share', package_name),\n        glob('launch/*launch.[pxy][yma]*'))\n],\n\n# ...\n\nentry_points={\n'console_scripts': [\n     # ...\n     'topic_latcher = ros2_course.topic_latcher:main',\n],\n</code></pre> </li> <li> <p>Start the simulator, move the joints using the Joint State Publisher GUI.</p> <pre><code>ros2 launch ros2_course view_ur.launch.py ur_type:=ur5e\n</code></pre> <p>Tip</p> <p>Try other robots using argument <code>ur_type</code> (ur3, ur3e, ur5, ur5e, ur10, ur10e, ur16e, ur20).</p> </li> </ol>"},{"location":"07_robotics_principles/#2-move-the-robot-in-joint-space","title":"2: Move the robot in joint space","text":"<ol> <li> <p>Create a new python source file named <code>ur_controller.py</code> in <code>~/ros2_ws/src/ros2_course/ros2_course</code> folder. Specify the new entry point in <code>setup.py</code> in the usual way. Subscribe to the topic publishing the robot's joint angles (configuration). Create publisher for the topic that can be used to set the joint angles.</p> <pre><code>/joint_states\n/set_joint_states\n</code></pre> </li> <li> <p>Move the robot to the configuration <code>q = [-1.28, 4.41, 1.54, -1.16, -1.56, 0.0]</code>.</p> </li> </ol>"},{"location":"07_robotics_principles/#3-kinematics","title":"3. Kinematics","text":"<ol> <li> <p>The simulator publishes the urdf description of the robot in a topic. Subscribe to this topic.</p> <pre><code>/robot_description_latch\n</code></pre> </li> <li> <p>Import the <code>kinpy</code> package and create the kinematic chain based on the urdf describing the robot in the callback function just implemented:</p> <pre><code>import kinpy as kp\n\n# ...\n\n\nself.chain = kp.build_serial_chain_from_urdf(self.desc, 'tool0')\nprint(self.chain.get_joint_parameter_names())\nprint(self.chain)\n</code></pre> </li> <li> <p>Calculate and print the TCP pose in the given configuration using the <code>kinpy</code> package.</p> <pre><code>p = chain.forward_kinematics(q)\n</code></pre> </li> </ol>"},{"location":"07_robotics_principles/#4-inverse-kinematics-with-jacobian-inverse-method","title":"4: Inverse kinematics with Jacobian inverse method","text":"<p>Write a method that implements the inverse kinematics problem on the robot using the Jacobian inverse method presented in the lecture. The orientation is ignored. Move the TCP to the position <code>(0.50, -0.60, 0.20)</code>.</p> <ol> <li> <p>Write a loop with a stop condition for the length of <code>delta_r</code> and <code>rclpy.ok()</code>.</p> </li> <li> <p>Calculate the difference between the desired and the current TCP positions (<code>delta_r</code>). Scale with the constant <code>k_1</code>.</p> </li> <li> <p>Set <code>omega</code> to <code>[0.0, 0.0, 0.0]</code> (ignore orientation).</p> </li> <li> <p>Concatenate <code>delta_r</code> and <code>omega</code>.</p> </li> <li> <p>Calculate the Jacobian matrix in the given configuration using the function <code>kp.jacobian.calc_jacobian(...)</code>.</p> </li> <li> <p>Calculate the pseudo-inverse of the Jacobian matrix <code>np.linalg.pinv(...)</code>.</p> </li> <li> <p>Calculate <code>delta_q</code> using the above formula.</p> </li> <li> <p>Increment the joint angles with the obtained values.</p> </li> </ol> <p>Plot the TCP trajectory using Matplotlib.</p> <pre><code>import matplotlib.pyplot as plt\n\n# ...\n\n# Plot trajectory\nax = plt.figure().add_subplot(projection='3d')\nax.plot(x, y, z, label='TCP trajectory',  ls='-', marker='.')\nax.legend()\nax.set_xlabel('x [m]')\nax.set_ylabel('y [m]')\nax.set_zlabel('z [m]')\nplt.show()\n</code></pre>"},{"location":"07_robotics_principles/#bonus-inverse-kinematics-with-orientation","title":"Bonus: Inverse kinematics with orientation","text":"<p>Complete the solution to the previous problem by including orientation in the inverse kinematics calculation.</p>"},{"location":"07_robotics_principles/#useful-links","title":"Useful links","text":"<ul> <li>https://github.com/UniversalRobots/Universal_Robots_ROS2_Driver/tree/humble</li> <li>https://docs.ros.org/en/ros2_packages/humble/api/ur_robot_driver/usage.html#usage-with-official-ur-simulator</li> <li>https://github.com/UniversalRobots/Universal_Robots_Client_Library</li> <li>https://pypi.org/project/kinpy/</li> <li>https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation</li> <li>https://www.rosroboticslearning.com/jacobian</li> </ul>"},{"location":"08_sensory_data/","title":"10. Szenzoros adatok gy\u0171jt\u00e9se \u00e9s feldolgoz\u00e1sa","text":""},{"location":"08_sensory_data/#gyakorlat","title":"Gyakorlat","text":"<p>Thing may change here...</p> <p>Ezt a gyakorlatot lehet, hogy le fogjuk cser\u00e9lni.</p>"},{"location":"08_sensory_data/#1-leo-rover","title":"1: Leo rover","text":"<ol> <li> <p>Install\u00e1ljuk a Leo rover ROS package-eit:</p> <pre><code>sudo apt update\nsudo apt install ros-noetic-leo*\n</code></pre> </li> <li> <p>A http://wiki.ros.org/leo_gazebo le\u00edr\u00e1s seg\u00edts\u00e9g\u00e9vel ind\u00edtsuk el a gazebo szimul\u00e1tort a Mars landscape-pel.</p> </li> <li> <p>Ind\u00edtsunk teleop node-ot, \u00e9s mozgassuk meg a robotot.</p> </li> </ol>"},{"location":"08_sensory_data/#2-kave-a-marson-kepek-rogzitese","title":"2: K\u00e1v\u00e9 a Marson -- k\u00e9pek r\u00f6gz\u00edt\u00e9se","text":"<p>Warning</p> <p>A Mars rover k\u00e9pet k\u00fcld\u00f6tt egy k\u00fcl\u00f6n\u00f6s, k\u00e1v\u00e9s b\u00f6gr\u00e9nek t\u0171n\u0151 t\u00e1rgyr\u00f3l! A feladat, hogy ford\u00edtsuk a rovert a b\u00f6gre fel\u00e9, majd k\u00f6zel\u00edts\u00fck meg, hogy r\u00e9szletesen megvizsg\u00e1lhassuk.</p> <p></p> <ol> <li> <p>Ind\u00edtsuk el a Gazebo-t:</p> <pre><code>    gazebo\n</code></pre> </li> <li> <p>Az <code>insert</code> panelen keress\u00fck ki a <code>googleresearch/models/cole_hardware_mug_classic_blue</code> modellt, majd helyezz\u00fck el a szimul\u00e1ci\u00f3ban. Ez az\u00e9rt kell, hogy k\u00e9s\u0151bb meglegyen a b\u00f6gre modellje a f\u00e1ljrendszer\u00fcnkben.</p> </li> <li> <p>Z\u00e1rjuk be a Gazebo-t</p> </li> <li> <p>T\u00f6lts\u00fck le a <code>leo_masryard_coffee.launch</code> \u00e9s a <code>marsyard_coffe.world</code> f\u00e1jlokat, majd m\u00e1soljuk be rendre a <code>catkin_ws/src/ros_course/launch</code> \u00e9s <code>catkin_ws/src/ros_course/worlds</code> mapp\u00e1kba.</p> </li> <li> <p>A <code>.world</code> f\u00e1jlokban \u00edrjuk \u00e1t a <code>/home/tamas/.ignition/fuel/fuel...</code> el\u00e9r\u00e9si utakat (f\u00e1jlonk\u00e9nt 2x) a saj\u00e1tunkra.</p> </li> <li> <p>Ind\u00edtsuk el a szimul\u00e1tort:</p> <pre><code>    roslaunch ros_course leo_marsyard_coffee.launch\n</code></pre> </li> <li> <p>Ind\u00edtsuk el a teleopot \u00e9s az <code>rqt_image_view</code>-t:</p> <pre><code>    rosrun leo_teleop key_teleop\n    ```\n\n```bash\n    rosrun rqt_image_view rqt_image_view\n</code></pre> <p>Tip</p> <p>Ha a szimul\u00e1tor futtat\u00e1sa t\u00fals\u00e1gosan megterhel\u0151 a PC sz\u00e1m\u00e1ra, dolgozhatunk a terrain n\u00e9lk\u00fcli <code>leo_gazebo_coffee.launch</code> \u00e9s <code>gazebo_coffe.world</code> f\u00e1jlokkal is.</p> </li> <li> <p>Ments\u00fcnk le egy-egy k\u00e9pet, amin l\u00e1that\u00f3, illetve nem l\u00e1that\u00f3 a k\u00e1v\u00e9s b\u00f6gre. </p> </li> </ol>"},{"location":"08_sensory_data/#3-kave-a-marson-offline-kepfeldolgozas","title":"3: K\u00e1v\u00e9 a Marson -- offline k\u00e9pfeldolgoz\u00e1s","text":"<ol> <li> <p>\u00cdrjunk Python szkriptet, amely beolvassa \u00e9s megjelen\u00edti a lementett k\u00e9peket.</p> </li> <li> <p>Sz\u00edn alap\u00fa szegment\u00e1l\u00e1ssal (vagy b\u00e1rhogy m\u00e1shogy) szegment\u00e1ljuk a k\u00e1v\u00e9s b\u00f6gr\u00e9t.</p> </li> <li> <p>Hat\u00e1rozzuk meg a b\u00f6gre k\u00f6z\u00e9ppontj\u00e1t k\u00e9pi koordin\u00e1t\u00e1kban.</p> </li> <li> <p>A szegment\u00e1l\u00e1s zaja gondot okozhat, pr\u00f3b\u00e1ljuk meg lesz\u0171rni.</p> </li> </ol>"},{"location":"08_sensory_data/#4-kave-a-marson-online-perception-node","title":"4: K\u00e1v\u00e9 a Marson -- online perception node","text":"<ol> <li> <p>Iratkozzunk fel a <code>/camera/image_raw</code> topicra, majd a <code>cv.imshow()</code> f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9val jelen\u00edts\u00fck meg a kapott k\u00e9peket.</p> </li> <li> <p>Dolgozzuk be a m\u0171k\u00f6d\u0151 computer vision algoritmusunkat egy ROS node-ba.</p> </li> <li> <p>Publik\u00e1ljuk \u00faj topicban a detekt\u00e1lt b\u00f6gre k\u00f6z\u00e9ppontj\u00e1nak k\u00e9pi koordin\u00e1t\u00e1t. Haszn\u00e1lhatjuk pl. az Int32MultiArray, Point2D t\u00edpusokat, vagy defini\u00e1lhatunk saj\u00e1tot (k\u00e9s\u0151bb sz\u00fcks\u00e9g lesz a b\u00f6gre m\u00e9ret\u00e9re is).</p> </li> <li> <p>B\u00f3nusz: publik\u00e1ljuk a maszkot \u00e9s a maszkolt k\u00e9pet egy-egy Image topicban</p> </li> </ol>"},{"location":"08_sensory_data/#5-kave-a-marson-operation-logic-node","title":"5: K\u00e1v\u00e9 a Marson -- operation logic node","text":"<ol> <li> <p>\u00cdrjunk \u00faj ROS node-ot, amely fogadja a perception node \u00fczeneteit, illetve k\u00e9pes a rover mozg\u00e1s\u00e1nak ir\u00e1ny\u00edt\u00e1s\u00e1ra.</p> </li> <li> <p>Forgassuk a rovert egy helyben, am\u00edg a b\u00f6gre a k\u00e9p k\u00f6zep\u00e9re nem ker\u00fcl.</p> </li> <li> <p>K\u00f6zel\u00edts\u00fck meg a b\u00f6gr\u00e9t annyira, hogy a l\u00e1tsz\u00f3lagos m\u00e9rete a k\u00e9p m\u00e9ret\u00e9nek 50%-\u00e1t el nem \u00e9ri.</p> </li> <li> <p>Ments\u00fcnk le k\u00e9pet a gyan\u00fas objektumr\u00f3l.</p> </li> </ol>"},{"location":"08_sensory_data/#51-bonusz","title":"5+1: B\u00f3nusz","text":"<ol> <li> <p>N\u00e9zz\u00fcnk sz\u00e9t Gazebo-ban a beilleszthet\u0151 modellek k\u00f6z\u00f6tt (<code>insert</code> panel) \u00e9s v\u00e1lasszunk egyet, amely valamilyen m\u00e1s m\u00f3dszerrel detekt\u00e1lhat\u00f3 a kamera k\u00e9p\u00e9n (pl. template matching).</p> </li> <li> <p>M\u00f3dos\u00edtsuk \u00fagy a node-okat, hogy ezt az objektumot k\u00f6zel\u00edtse meg a rover.</p> <p>Figyelem!</p> <p>Az \u00f3ra v\u00e9g\u00e9n a forr\u00e1sk\u00f3dokat mindenkinek fel kell t\u00f6lteni Moodle-re egy zip arch\u00edvumba csomagolva!</p> </li> </ol>"},{"location":"08_sensory_data/#hasznos-linkek","title":"Hasznos linkek","text":"<ul> <li>http://wiki.ros.org/leo_gazebo</li> <li>http://wiki.ros.org/cv_bridge/Tutorials/ConvertingBetweenROSImagesAndOpenCVImagesPython</li> <li>https://realpython.com/python-opencv-color-spaces/</li> <li>https://stackoverflow.com/questions/59164192/how-to-find-the-contour-of-a-blob-using-opencv-python</li> </ul>"},{"location":"projects/","title":"Projects","text":""},{"location":"projects/#challenge-levels-and-grades","title":"Challenge levels and grades","text":"<p>Projects can be completed at three Challenge levels. The Challenge level determines the  best grade that can be received to the project! </p> Challenge level Best grade Basic 3 Advanced 4 Epic 5 <p>Tip</p> <p>The projects are defined in a way that it is recommended to tart with the Basic level, and then gradually work towards Epic.</p> <p>The projects are graded based on the follwoing aspects:</p> <ul> <li>Proved to be the student's own work</li> <li>Running results valid output</li> <li>Usage of versioning, usage of GitHub/GitLab/other repository</li> <li>Grading: <ul> <li>completeness of the soultion</li> <li>proper ROS communication</li> <li>proper structure of the program</li> <li>quality of implementation</li> <li>documentation quality</li> </ul> </li> </ul>"},{"location":"projects/#schedule","title":"Schedule","text":"Week Date Event 7. oct. 27 Announcement of project topics. Project lab I. 12. dec. 1 Project lab II. 14. dec. 15 Project presentations."},{"location":"projects/#grading","title":"Grading","text":"<p>Personal attendance on the classes is mandatory (min 70%).</p> <p>To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again.</p> <p>Grade</p> <p>\\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) </p>"},{"location":"projects/#project-topics","title":"Project topics","text":""},{"location":"projects/#1-mobil-robot","title":"1. Mobil robot","text":""},{"location":"projects/#a-playground-robot","title":"A. Playground Robot","text":"<ul> <li>Gazebo install</li> <li>Setting up a robot simulation (Gazebo)</li> </ul>"},{"location":"projects/#b-turtlebot4","title":"B. TurtleBot4","text":"<ul> <li>TurtleBot4 Simulator Tutorial</li> <li>TurtleBot4 GUI Docs</li> </ul>"},{"location":"projects/#c-platypous-ros-1","title":"C. PlatypOUs (ROS 1)","text":"<ul> <li>PlatypOUs GitHub</li> </ul>"},{"location":"projects/#d-any-mobile-robot","title":"D. Any mobile robot","text":""},{"location":"projects/#11-mobile-robot-obstacle-avoidance","title":"1.1. Mobile robot obstacle avoidance","text":"<ul> <li>Basic: SSimulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system to detect obstacle. Calculation and execution of a trajectory avoiding the obstacle in the simulator, using any sensor of the robot.</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#12-mobile-robot-path-following","title":"1.2. Mobile robot path following","text":"<ul> <li>Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system for path follwoing in the simulator, using any sensor of the robot (e.g., driving next to the wall with given distance using LIDAR).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#13-mobile-robot-object-follwoing","title":"1.3. Mobile robot object follwoing","text":"<ul> <li>Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system to detect an object and follow it in the simulator, using any sensor of the robot(e.g., visual servoing).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#14-mobile-robot-action-library","title":"1.4. Mobile robot action library","text":"<ul> <li>Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS action library containing simple actions and their execution (e.g., push object, move to object, turn around).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#2-quadcopter","title":"2. Quadcopter","text":"<ul> <li>Gazebo install</li> <li> <p>Setting up a robot simulation (Gazebo)</p> <pre><code>ign gazebo -v 4 -r quadcopter.sdf\n</code></pre> </li> </ul> <p></p> <ul> <li>Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot.  </li> <li>Advanced: ROS system implementation to control velocity/position.</li> <li>Epic: Impress me!</li> </ul>"},{"location":"projects/#3-any-gazebo-simulaion","title":"3. Any Gazebo simulaion","text":"<ul> <li>Gazebo install</li> <li>Setting up a robot simulation (Gazebo)</li> <li>Gazebo World Examples</li> </ul> <p>Based on discussion.</p>"},{"location":"projects/#4-gazebo-simulation-creation","title":"4. Gazebo simulation creation","text":"<ul> <li>Gazebo install</li> <li>Setting up a robot simulation (Gazebo)</li> <li>Gazebo World Examples</li> </ul> <p>Based on discussion.</p>"},{"location":"projects/#5-turtlesim","title":"5. TurtleSim","text":"<ul> <li>Turtlesim Tutorial</li> <li>Koch snowflake</li> </ul>"},{"location":"projects/#51-turtlesim-fraktalszoveg","title":"5.1 Turtlesim Frakt\u00e1l/Sz\u00f6veg","text":"<ul> <li>Basic: Implement a proportianl controller.</li> <li>Advanced: Draw fractal/text.</li> <li>Epic: Impress me!</li> </ul>"},{"location":"projects/#6-dvrk","title":"6. DVRK","text":"<ul> <li>Download and compile dVRK 2</li> <li>Marker examples</li> </ul>"},{"location":"projects/#61-dvrk-interactive-marker","title":"6.1 DVRK Interactive Marker","text":"<p>Graspable, movable marker for the DVRK simulator.</p>"},{"location":"projects/#7-youbot-windows","title":"7. YouBot (Windows)","text":"<ul> <li>YouBot controller GitHub</li> </ul>"},{"location":"projects/#71-youbot-ros-integration","title":"7.1. YouBot ROS integration","text":"<ul> <li>Basic: YouBot repo build.</li> <li>Advanced: ROS wrapper/interface implementation, move the simulated arm in joint space from ROS.</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#x-custom-topic","title":"X. Custom topic","text":"<p>Based on discussion.</p>"},{"location":"projects/#links","title":"Links","text":"<ul> <li>Gazebo install</li> <li>Setting up a robot simulation (Gazebo)</li> <li>Gazebo World Examples</li> <li>YouBot controller GitHub</li> <li>Download and compile dVRK 2</li> <li>Marker examples</li> <li>Turtlesim Tutorial</li> <li>Koch snowflake </li> </ul>"}]}