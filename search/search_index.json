{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#course-information","title":"Course Information","text":""},{"location":"#schedule","title":"Schedule","text":"Week Date Topic Test 1. Sept 15 Requirements. ROS introduction. Setup the development environment. - 2. Sept 22 Setup the development environment. Linux principles. ROS principles. Running examples. ROS package. Basics of ROS communication, implementation of publisher and subscriber. Project topic announcements. 4. Oct 6 Python principles. Practicing ROS communication, solving examples. - 5. Oct 13 Principles of robotics. Programming a da Vinci surgical robot in simulated environment I. - 6. Oct 20 Principles of robotics. Programming a da Vinci surgical robot in simulated environment II. - 7. Oct 27 Versioning, Git. Project labor I. Test 1 8. Nov 3 ROS 2 Launch, Param, Bag - 9. Nov 10 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space I. - 10. Nov 17 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space II. - 11. Nov 24 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space III. - 12. Dec 1 Project labor II. - 13. Dec 8 - Test 2 14. Dec 15 Project presentations. Test retake 14+1. Dec 19 (Tue) - Mid-term replacement <p>Warning</p> <p>The schedule may change during the semester!</p>"},{"location":"#course-requirements","title":"Course Requirements","text":""},{"location":"#project","title":"Project","text":"<ul> <li>Proved to be the student's own work</li> <li>Running results valid output</li> <li>Grading: completeness of the soultion, proper ROS communication, proper structure of the program, quality of implementation, documentation</li> </ul>"},{"location":"#grading","title":"Grading","text":"<p>Personal attendance on the classes is mandatory (min 70%).</p> <p>To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again.</p> <p>Grade</p> <p>\\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) </p>"},{"location":"#course-supervisor","title":"Course Supervisor","text":"<p>Dr. P\u00e9ter Galambos   peter.galambos@irob.uni-obuda.hu</p>"},{"location":"#teachers","title":"Teachers","text":"<p>Tam\u00e1s Levendovics  tamas.levendovics@irob.uni-obuda.hu</p> <p>Borsa D\u00e9t\u00e1r   detar.borsa@gmail.com</p>"},{"location":"#antal-bejczy-center-for-intelligent-robotics-barkirob","title":"Antal Bejczy Center for Intelligent Robotics (BARK/IROB)","text":"<p>https://irob.uni-obuda.hu</p>"},{"location":"#irob-saf","title":"irob-saf","text":"<p>(iRob Surgical Automation Framework)</p> <p>https://github.com/ABC-iRobotics/irob-saf</p>"},{"location":"#platypous","title":"PlatypOUs","text":"<p>https://github.com/ABC-iRobotics/PlatypOUs-Mobile-Robot-Platform</p>"},{"location":"01_intro/","title":"01. Introduction","text":""},{"location":"01_intro/#robot-operating-system-ros-introduction","title":"Robot Operating System (ROS) introduction","text":""},{"location":"01_intro/#the-definition-of-robot","title":"The definition of robot","text":"<ul> <li>Joseph Engelberger, pioneer in industrial robotics: \"I can't define a robot, but I know one when I see one.\"</li> <li>Wikipedia: \"A robot is a machine\u2014especially one programmable by a computer\u2014 capable of carrying out a complex series of actions automatically. Robots can be guided by an external control device or the control may be embedded within. Robots may be constructed on the lines of human form, but most robots are machines designed to perform a task with no regard to their aesthetics.\"</li> <li>ISO 8373:2012 Robots and robotic devices \u2013 Vocabulary, FDIS 2012: \"A robot is an actuated mechanism programmable in two or more axes with a degree of autonomy, moving within its environment, to perform intended tasks.\"</li> <li>Rodney Brooks, Founder and CTO, Rethink Robotics: \"A robot is some sort of device, wich has sensors those sensors the world, does some sort of computation, decides on an action, and then does that action based on the sensory input, which makes some change out in the world, outside its body. Comment: the part \"make some change outside its body\" discriminates a washing machine from e.g. a Roomba.\"</li> <li>Tam\u00e1s Haidegger, Encyclopedia of Robotics: \"A robot is a complex mechatronic system enabled with electronics, sensors, actuators and software, executing tasks with a certain degree of autonomy. It may be pre-programmed, teleoperated or carrying out computations to make decisions.\"</li> </ul>"},{"location":"01_intro/#what-is-ros","title":"What is ROS?","text":"<ul> <li>Open-source, robotics themed middleware</li> <li>Modularity, reusability (drivers, algorithms, libraries, ...)</li> <li>Hardware abstraction, ROS API</li> <li>C++ \u00e9s Python support</li> <li>Ubuntu Linux (except ROS 2)</li> <li>Great community</li> </ul>"},{"location":"01_intro/#history","title":"History","text":"<ul> <li>Mid 2000s, Stanford: robotics themed, flexible, dynamic framework for prototype development</li> <li>2007, Willow Garage: incubation, the core of ROS under BSD license</li> <li>Spread in robotics reserach, PR2</li> <li>2012: Industrial robotics, ROS-Industrial</li> <li>2017: ROS 2</li> </ul>"},{"location":"01_intro/#development-system-build-homework","title":"Development system build -- homework","text":"<p>Recommended environment:</p> <ul> <li>Ubuntu 22.04</li> <li>ROS2 Humble</li> <li>IDE: QtCreator</li> </ul>"},{"location":"01_intro/#ros-2-humble-hawksbill","title":"ROS 2 Humble Hawksbill","text":"<p>Setup locale.</p> <pre><code>```bash\nlocale  # check for UTF-8\n\nsudo apt update &amp;&amp; sudo apt install locales\nsudo locale-gen en_US en_US.UTF-8\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nexport LANG=en_US.UTF-8\n\nlocale  # verify settings\n```\n\n---\n</code></pre> <ol> <li> <p>ROS 2 Humble install</p> <pre><code>sudo apt install software-properties-common\nsudo add-apt-repository universe\nsudo apt update &amp;&amp; sudo apt install curl -y\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\nsudo apt update\nsudo apt upgrade\nsudo apt install ros-humble-desktop\nsudo apt install ros-dev-tools\n</code></pre> </li> <li> <p>Test the new ROS 2 install:</p> <pre><code>source /opt/ros/humble/setup.bash\nros2 run demo_nodes_py talker\n</code></pre> </li> <li> <p>The <code>source</code> command is responsible for setting the environment variables, which must be specified each time a new terminal window is opened. This command can be inserted at the end of the <code>~/.bashrc</code> file, which is run every time a terminal window is opened, so you don't have to type it every time (ROS 2 will be the default):</p> <pre><code>echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre> </li> </ol>"},{"location":"01_intro/#tovabbi-csomagok","title":"Tov\u00e1bbi csomagok","text":"<ol> <li> <p>We will also need the following packages during the semester, so these should be installed as well:</p> <pre><code>sudo apt install libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev python3-osrf-pycommon libasound2-dev libgl1-mesa-dev xorg-dev python3-vcstool python3-colcon-common-extensions python3-pykdl libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev libbluetooth-dev ros-humble-joint-state-publisher* ros-humble-xacro gfortran-9\n</code></pre> </li> </ol>"},{"location":"01_intro/#ide","title":"IDE","text":"<ol> <li> <p>QtCreator</p> <p>Currently, one of the most widely used IDEs for developing ROS packages is QtCreator, for which a ROS plugin has been developed. The installer is available at the link below. You should use the \"18.04 offline installer\", it also works on Ubuntu 22.04.</p> <p>https://ros-qtc-plugin.readthedocs.io/en/latest/_source/How-to-Install-Users.html</p> <p>Once downloaded, the IDE can be installed using the command below (it is important to put <code>cd</code> in the download location):</p> <pre><code>chmod +x qtcreator-ros-bionic-latest-offline-installer.run\nsudo ./qtcreator-ros-bionic-latest-offline-installer.run\n</code></pre> <p>When the installer asks you where to install it, change it to e.g. <code>/home/&lt;USER&gt;/QtCreator</code>. If you put it in root, you will not be able to run it. After installation, look for `Qt Creator (4.9.2)'.</p> </li> <li> <p>CLion</p> <p>CLion has a high level of ROS integration, and its use is most recommended for this course. A free student license can be obtained at https://www.jetbrains.com/community/education/#students</p> <p>After installation, browse to the file <code>/var/lib/snapd/desktop/applications/clion_clion.desktop</code>. Copy the appropriate line here so that the IDE will use the environment set by the terminal:</p> <pre><code>Exec=bash -i -c \"/snap/bin/clion\" %f\n</code></pre> </li> <li> <p>Visual Studio</p> <p>Microsoft Visual Studio also supports source code for ROS, this IDE can also be used during the semester.</p> </li> </ol> <p>Suggestion</p> <p>Install Terminator terminal emulator: <pre><code>sudo apt update\nsudo apt install terminator\n</code></pre></p>"},{"location":"01_intro/#links","title":"Links","text":"<ul> <li>https://www.ros.org/</li> <li>ROS 2 Humble installation</li> <li>QtCreator + ROS plugin</li> <li>IROB virtual tour</li> </ul>"},{"location":"02_linux_ros_principles/","title":"02. Linux, ROS introduction","text":""},{"location":"02_linux_ros_principles/#lecture","title":"Lecture","text":""},{"location":"02_linux_ros_principles/#linux-principles","title":"Linux principles","text":"<ul> <li>(Was) the only OS supported by ROS</li> <li>Security</li> <li>Efficieny</li> <li>Open-source</li> <li>Community support</li> <li>User freedom</li> <li>Distributions: Ubuntu, Linux Mint, Debian, etc.</li> <li>Terminal usage more dominant</li> </ul> <p>Suggestion</p> <p>Install Terminator terminal emulator: <pre><code>sudo apt update\nsudo apt install terminator\n</code></pre></p>"},{"location":"02_linux_ros_principles/#linux-commands","title":"Linux commands","text":"<p>See some basic commands below:</p> <ul> <li>Run as administrator with <code>sudo</code></li> <li>Manual of command <code>man</code>, e.g. <code>man cp</code></li> <li>Package management <code>apt</code>, e.g. <code>apt update</code>, <code>apt install</code></li> <li>Navigation <code>cd</code></li> <li>List directory contents <code>ls</code></li> <li>Create file <code>touch</code></li> <li>Copy file <code>cp</code></li> <li>Move file <code>mv</code></li> <li>Remove file <code>rm</code></li> <li>Make directory <code>mkdir</code></li> <li>Remove directory <code>rmdir</code></li> <li>Make a file executable <code>chmod +x &lt;filename&gt;</code></li> <li>Safe restart: Crtl + Alt + PrtScr + REISUB</li> <li>If not sure, just google the command</li> </ul>"},{"location":"02_linux_ros_principles/#ros-1-ros-2","title":"ROS 1 \u2192 ROS 2","text":"<ul> <li>ROS 2 was rewritten from scratch</li> <li>More modular architecture</li> <li>Improved support for real-time systems</li> <li>Support for multiple communication protocols</li> <li>Better interoperability with other robotic systems</li> <li>Focus on standardization and industry collaboration</li> <li>No ROS Master</li> <li>No Devel space</li> <li><code>rclpy</code>, <code>rclcpp</code></li> <li>More structured code (<code>Node</code> class)</li> <li>Different build system</li> <li>Platforms: Windows, OS X, Linux</li> </ul>"},{"location":"02_linux_ros_principles/#ros-principles","title":"ROS principles","text":""},{"location":"02_linux_ros_principles/#ros-workspace","title":"ROS workspace","text":"<p>Colcon workspace</p> <p>A folder where packages are modified, built, and installed.</p> <p></p> <ul> <li>Source space:<ul> <li>Source code of colcon packages</li> <li>Space where you can extract/checkout/clone source code for the packages you want to build</li> </ul> </li> <li>Build space<ul> <li>Colcon is invoked here to build packages</li> <li>Colcon and CMake keep intermediate files here</li> </ul> </li> <li>Install space:<ul> <li>Each package will be installed here; by default each package will be installed into a separate subdirectory</li> </ul> </li> <li>Log space:<ul> <li>Contains various logging information about each colcon invocation</li> </ul> </li> </ul> <p>ROS package principle</p> <p>Enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software.</p> <p>ROS dependencies</p> <p>After cloning a new package, use the following command to install depenencies: <pre><code>rosdep install --from-paths src --ignore-src -r -y\n</code></pre></p>"},{"location":"02_linux_ros_principles/#ros-package","title":"ROS package","text":"<ul> <li>Main unit to organize software in ROS</li> <li>Buildable and redistributable unit of ROS code</li> <li>Consists of (in the case of Python packages):<ul> <li><code>package.xml</code> file containing meta information about the package<ul> <li>name</li> <li>version</li> <li>description</li> <li>dependencies</li> <li>etc.</li> </ul> </li> <li><code>setup.py</code> containing instructions for how to install the package</li> <li><code>setup.cfg</code> is required when a package has executables, so ros2 run can find them</li> <li><code>/&lt;package_name&gt;</code> - a directory with the same name as your package, used by ROS 2 tools to find your package, contains <code>__init__.py</code></li> <li>Anything else</li> </ul> </li> <li><code>ros2 run turtlesim turtlesim_node</code></li> </ul> <p>CMake</p> <p>For CMake packages (C++), the package contents will be different.</p> <p></p>"},{"location":"02_linux_ros_principles/#ros-node","title":"ROS node","text":"<ul> <li>Executable part of ROS:<ul> <li>python scripts</li> <li>compiled C++ code</li> </ul> </li> <li>A process that performs computation</li> <li>Inter-node communication:<ul> <li>ROS topics (streams)</li> <li>ROS parameter server</li> <li>Remote Procedure Calls (RPC)</li> <li>ROS services</li> <li>ROS actions</li> </ul> </li> <li>Meant to operate at a fine-grained scale</li> <li>Typically, a robot control system consists of many nodes, like:<ul> <li>Trajectory planning</li> <li>Localization</li> <li>Read sensory data</li> <li>Process sensory data</li> <li>Motor control</li> <li>User interface</li> <li>etc.</li> </ul> </li> </ul>"},{"location":"02_linux_ros_principles/#ros-build-system-colcon","title":"ROS build system---Colcon","text":"<ul> <li>System for building software packages in ROS</li> </ul>"},{"location":"02_linux_ros_principles/#environmental-setup-file","title":"Environmental setup file","text":"<ul> <li>setup.bash</li> <li>generated during init process of a new workspace</li> <li>extends shell environment</li> <li>ROS can find any resources that have been installed or built to that location</li> </ul> <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre>"},{"location":"02_linux_ros_principles/#practice","title":"Practice","text":""},{"location":"02_linux_ros_principles/#1-turtlesim","title":"1: Turtlesim","text":"<ol> <li> <p>Start <code>turtlesim_node</code> and <code>turtle_teleop_key</code> nodes with the following commands, in separate terminal windows:</p> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <pre><code>ros2 run turtlesim turtle_teleop_key\n</code></pre> <p>Tip</p> <p>In Terminator, you can further divide the given window with Ctrl-Shift-O, Ctrl-Shift-E key combinations. Ctrl-Shift-W closes the active window.</p> <p>Abort execution</p> <p><code>Ctrl-C</code></p> </li> <li> <p>Running the following ROS commands can provide useful information:</p> <pre><code>ros2 wtf\nros2 node list\nros2 node info /turtlesim\nros2 topic list\nros2 topic info /turtle1/cmd_vel\nros2 interface show geometry_msgs/msg/Twist\nros2 topic echo /turtle1/cmd_vel\n</code></pre> </li> <li> <p>Start <code>rqt_gui</code> with the following command:</p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Display the running nodes and topics in <code>rqt_gui</code>: Plugins \u2192 Introspection \u2192 Node Graph.</p> </li> <li> <p>Publish to the <code>/turtle1/cmd_vel</code> topic also using <code>rqt_gui</code>: Plugins \u2192 Topics \u2192 Message Publisher.</p> </li> </ol> <p></p>"},{"location":"02_linux_ros_principles/#2-ros-2-workspace-creation","title":"2: ROS 2 workspace creation","text":"<ol> <li> <p>Let's create a new ROS2 workspace with the name <code>ros2_ws</code>.</p> <pre><code>mkdir -p ~/ros2_ws/src\n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#3-ros-2-package-creation","title":"3: ROS 2 package creation","text":"<ol> <li> <p>Let's create a new ROS2 package with the name <code>ros2_course</code> and a Hello World.</p> <pre><code>cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python --node-name hello ros2_course\n</code></pre> <p>Syntax</p> <p><code>ros2 pkg create --build-type ament_python &lt;package_name&gt;</code> </p> </li> <li> <p>Build the workspace.</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\n</code></pre> <p>Symlink</p> <p>The option <code>--symlink-install</code> links the source scripts to the Install space, so we don't have to build again after modification.  </p> </li> <li> <p>Insert the following line at the end of the <code>~/.bashrc</code> file:</p> <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre> <p>Import to QtCreator</p> <p>New file or project \u2192 Other project \u2192 ROS Workspace. Select Colcon as Build System and <code>ros2_ws</code> as Workspace path.  </p> <p>Import to CLion</p> <p>Set the Python interpreter to Python 3.8, <code>/usr/bin/python3</code>. Add the follwong path: <code>/opt/ros/foxy/lib/python3.8/site-packages</code>. Hozzuk l\u00e9tre a <code>compile_commands.json</code> f\u00e1jlt a <code>~/ros2_ws/build</code> k\u00f6nyvt\u00e1rban az al\u00e1bbi tartalommal: <pre><code>[\n]\n</code></pre></p> </li> <li> <p>Test Hello World:</p> <pre><code>ros2 run ros2_course hello \n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#4-implementing-a-publisher-in-python","title":"4: Implementing a Publisher in Python","text":"<ol> <li> <p>Navigate to the <code>ros2_ws/src/ros2_course/ros2_course</code> folder and create the <code>talker.py</code> file with the content below.</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'talker = ros2_course.talker:main',\n</code></pre> </li> </ol> <ol> <li> <p>Build and run the node:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course talker\n</code></pre> </li> <li> <p>Check the output of the node using <code>ros2 topic echo</code> command or <code>rqt_gui</code>.</p> </li> </ol>"},{"location":"02_linux_ros_principles/#5-implementing-a-subscriber-in-python","title":"5: Implementing a Subscriber in Python","text":"<ol> <li> <p>Navigate to the <code>ros2_ws/src/ros2_course/ros2_course</code> folder and create the <code>listener.py</code> file with the content below.</p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\n\nclass MinimalSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard msg: \"%s\"' % msg.data)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'listener = ros2_course.listener:main',\n</code></pre> </li> <li> <p>Build and run both nodes:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course talker\n</code></pre> <pre><code>ros2 run ros2_course listener\n</code></pre> </li> </ol> <ol> <li> <p>Use <code>rqt_gui</code> to display the nodes and topics of the running system: </p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"02_linux_ros_principles/#useful-links","title":"Useful links","text":"<ul> <li>ROS 2 Tutorials</li> <li>What is a ROS 2 package?</li> </ul>"},{"location":"03_python_principles/","title":"03. Python principles, ROS Publisher, ROS Subscriber","text":""},{"location":"03_python_principles/#lecture","title":"Lecture","text":""},{"location":"03_python_principles/#python-principles","title":"Python principles","text":"<ul> <li>Interpreted, high-level programming language</li> <li>Name tribute to the comedy group Monty Python</li> <li>Powerful, still easy to learn, easy to use</li> <li>Readability</li> <li>Whitespace indentation</li> </ul> <ul> <li>Dynamically-typed</li> <li>Garbage colector and reference counting</li> <li>Object oriented programming</li> <li>Used in: AI, web applications, scientific computing, and many other areas</li> <li><code>python3</code></li> </ul>"},{"location":"03_python_principles/#python-syntax","title":"Python syntax","text":"<pre><code>import numpy as np\nimport math\n\nclass A:\n    def __init__(self, name):\n        self.name = name\n\n    def do_something(self):\n        # will do something\n        print(self.name + \" is doing something.\")\n\n    def count_to(self, n):\n        # count to n, tell if the number is odd or even\n        for i in range(n):\n            if i % 2 == 0:\n                print(i + \", it's even.\")\n            else:\n                print(i + \", it's odd.\")\n\n\n\nif __name__ == \"__main__\":\n    a = A(\"John\")\n    a.do_something()\n    a.count_to(10)\n</code></pre>"},{"location":"03_python_principles/#practice","title":"Practice","text":""},{"location":"03_python_principles/#1-move-the-turtle-in-a-straight-line","title":"1: Move the turtle in a straight line","text":"<ol> <li>Let's write a ROS node that moves the turtle forward along a straight line for a given distance.    Let's open a terminal. Let's create <code>~/ros2_ws/src/ros2_course/ros2_course</code>    the <code>turtlesim_controller.py</code> file in our directory:</li> </ol> <pre><code>```bash\ncd ros2_ws/src/ros2_course/ros2_course\ntouch turtlesim_controller.py\n```\n\n\n---\n</code></pre> <ol> <li> <p>Add a new entry point in the <code>setup.py</code> file:</p> <pre><code>'turtlesim_controller = ros2_course.turtlesim_controller:main',\n</code></pre> </li> </ol> <ol> <li> <p>Copy the skeleton of the program into <code>turtlesim_controller.py</code>:</p> <pre><code>import math\nimport rclpy\nfrom rclpy.node import Node\n\n\nclass TurtlesimController(Node):\n\n    def __init__(self):\n        super().__init__('turtlesim_controller')\n\n\n    def go_straight(self, speed, distance):\n        # Implement straght motion here\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tc = TurtlesimController()\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    tc.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> </ol> <ol> <li> <p>Let's start a <code>turtlesim_node</code> and then examine the topic,    with which we can control. In two separate terminal windows:</p> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <pre><code>ros2 topic list\nros2 topic info /turtle1/cmd_vel\nros2 interface show geometry_msgs/msg/Twist\n</code></pre> <p>Or use<code>rqt_gui</code>:</p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Import the message type <code>geometry_msgs/msg/Twist</code> and create the publisher in <code>turtlesim_controller.py</code>:</p> <pre><code>from geometry_msgs.msg import Twist\n\n#...\n\n# In the constructor:\nself.twist_pub = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)\n</code></pre> </li> <li> <p>We implement the <code>go_straight</code> method. Let's calculate how long it takes,    so that the turtle covers the given distance at the given speed. Publish a message    with which we set the speed, then wait for the calculated time, after that    send another message to reset the speed.    A little help for using the API:</p> <pre><code># Create and publish msg\nvel_msg = Twist()\nif distance &gt; 0:\n    vel_msg.linear.x = speed\nelse:\n    vel_msg.linear.x = -speed\nvel_msg.linear.y = 0.0\nvel_msg.linear.z = 0.0\nvel_msg.angular.x = 0.0\nvel_msg.angular.y = 0.0\nvel_msg.angular.z = 0.0\n\n# Set loop rate\nloop_rate = self.create_rate(100, self.get_clock()) # Hz\n\n# Calculate time\n# T = ...\n\n# Publish first msg and note time when to stop\nself.twist_pub.publish(vel_msg)\n# self.get_logger().info('Turtle started.')\nwhen = self.get_clock().now() + rclpy.time.Duration(seconds=T)\n\n# Publish msg while the calculated time is up\nwhile (some condition...) and rclpy.ok():\n    self.twist_pub.publish(vel_msg)\n    # self.get_logger().info('On its way...')\n    rclpy.spin_once(self)   # loop rate\n\n# turtle arrived, set velocity to 0\nvel_msg.linear.x = 0.0\nself.twist_pub.publish(vel_msg)\n# self.get_logger().info('Arrived to destination.')\n</code></pre> </li> <li> <p>Build and run the node:</p> <pre><code>cd ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course turtlesim_controller\n</code></pre> </li> </ol>"},{"location":"03_python_principles/#2-draw-shapes","title":"2: Draw shapes","text":"<ol> <li> <p>Let's implement the method for turning with a given angle a    in <code>turtlesim_controller.py</code>, similar to straight motion.</p> <pre><code>def turn(self, omega, angle):\n        # Implement rotation here\n</code></pre> </li> <li> <p>Let's implement the straight movement method of drawing a square with a turtle    and using the methods that perform the turn.</p> <pre><code>def draw_square(self, speed, omega, a):\n</code></pre> </li> <li> <p>Let's implement the method of drawing any regular shape with a turtle    using the methods that perform straight movement and turning.</p> <pre><code>def draw_poly(self, speed, omega, N, a):\n</code></pre> </li> </ol>"},{"location":"03_python_principles/#3-go-to-function","title":"3: Go to function","text":"<ol> <li> <p>Let's examine the topic on which <code>turtlesim_node</code> publishes its current position.</p> <pre><code>ros2 topic list\nros2 topic info /turtle1/pose\nros2 interface show turtlesim/msg/Pose\n</code></pre> <p>Or use <code>rqt_gui</code>:  </p> <pre><code>ros2 run rqt_gui rqt_gui\n</code></pre> </li> <li> <p>Let's define a subscriber for the topic and write the callback function.</p> <pre><code># Imports\nfrom turtlesim.msg import Pose\n\n    # Constructor\n    self.pose = None\n    self.subscription = self.create_subscription(\n        Pose,\n        '/turtle1/pose',\n        self.cb_pose,\n        10)\n\n    # New method for TurtlesimController\n    def cb_pose(self, msg):\n        self.pose = msg  \n</code></pre> </li> </ol> <ol> <li> <p>We implement the <code>go_to</code> method. Let's test it, call it from main.</p> <pre><code># ...\n\n# Go to method\n    def go_to(self, speed, omega, x, y):\n        # Wait for position to be received\n        loop_rate = self.create_rate(100, self.get_clock()) # Hz\n        while self.pose is None and rclpy.ok():\n            self.get_logger().info('Waiting for pose...')\n            rclpy.spin_once(self)\n\n        # Stuff with atan2\n\n\n# Main\ndef main(args=None):\n    rclpy.init(args=args)\n    tc = TurtlesimController()\n\n    tc.go_to(1.0, 20.0, 2, 8)\n    tc.go_to(1.0, 20.0, 2, 2)\n    tc.go_to(1.0, 20.0, 3, 4)\n    tc.go_to(1.0, 20.0, 6, 2)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    tc.destroy_node()\n    rclpy.shutdown()  \n</code></pre> </li> </ol> <p></p>"},{"location":"03_python_principles/#extra-advanced-go-to","title":"Extra: Advanced go to","text":"<p>Write a go to function that uses a proportional controller.</p>"},{"location":"03_python_principles/#useful-links","title":"Useful links","text":"<ul> <li>For loops in python</li> <li>Some python functions</li> <li>Turtlesim help</li> <li>atan2</li> </ul>"},{"location":"04_da_vinci/","title":"04. Principles of robotics. Programming a da Vinci surgical robot in simulated environment.","text":""},{"location":"04_da_vinci/#lecture","title":"Lecture","text":"<p>Warning</p> <p>Test 1 (ROS principles, publisher, subscriber. Python principles. Principles of robotics.) October 27.</p>"},{"location":"04_da_vinci/#rigid-body-motion","title":"Rigid body motion","text":"<p>Def. Rigid body</p> <p>A rigid body is defined as a body on which the distance between two points remains constant in time regardless of the force applied on it.</p> <ul> <li>Shape and the volume of the rigid bodies are also constant.</li> <li>The pose of a rigid body can be given by the three coordinates of three of its points that do not lie on the same straight line.</li> </ul> <p></p> <ul> <li> <p>The pose of a rigid body can be described in a more expressive way by the three coordinates of one of its points chosen arbitrarily position and the body's orientation.</p> </li> <li> <p>The motion of rigid bodies is composed by two elemental motions: translation and rotation. </p> </li> <li> <p>During translation, all points of the body move along straight, parallel lines. </p> </li> </ul> <p></p> <ul> <li> <p>During rotation, the position of the points of the rotational axis are constant, and the other points of the body move along circles in planes perpendicular to the axis of rotation.</p> </li> <li> <p>The free motion of rigid bodies can always be expressed  as the superposition of a translational motion and a rotation around a single axis.</p> </li> </ul>"},{"location":"04_da_vinci/#3d-transformations","title":"3D transformations","text":"<ul> <li>Position: 3D offset vector  </li> <li> <p>Orientation: 3 x 3 rotation matrix</p> <ul> <li>further orientation representations: Euler-angles, RPY, angle axis, quaternion</li> </ul> </li> <li> <p>Pose: 4 \u00d7 4 (homogenous) transformation matrix</p> </li> <li>Frame: origin, 3 axes, 3 base vectors, right hand rule</li> <li>Homogenous transformation: rotation and translation in one transfromation<ul> <li>e.g., for the rotation \\(\\mathbf{R}\\) and translation \\(\\mathbf{v}\\):</li> </ul> </li> </ul> \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right] = \\left[\\matrix{r_{1,1} &amp; r_{1,2} &amp; r_{1,3} &amp; v_x\\\\r_{2,1} &amp; r_{2,2} &amp; r_{2,3} &amp; v_y\\\\r_{3,1} &amp; r_{3,2} &amp; r_{3,3} &amp; v_z\\\\\\ 0 &amp; 0 &amp; 0 &amp; 1 }\\right] \\] <ul> <li>Homogenous coordinates: <ul> <li>Vector: extended with 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\)</li> <li>Point: extended by 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\)</li> <li>Applying transfomrations is much easier:</li> </ul> </li> </ul> \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] <ul> <li>Degrees of Freedom (DoF): the number of independent parameters.</li> </ul>"},{"location":"04_da_vinci/#principles-of-robotics","title":"Principles of robotics","text":"<ul> <li>Robots are built of: segments (or links) \u00e9s joints</li> <li>Task space (or cartesian space):<ul> <li>3D space around us, where the task, endpoint trajectories, obstacles are defined.</li> <li>TCP (Tool Center Point): Frame fixed to the end effector of the robot.</li> <li>Base frame, world frame</li> </ul> </li> <li>Joint space:<ul> <li>Properties or values regarding the joints.</li> <li>Low-level controller.</li> <li>Joint angles, joint velocities, accelerations, torques....</li> </ul> </li> </ul>"},{"location":"04_da_vinci/#python-libraries","title":"Python libraries","text":""},{"location":"04_da_vinci/#numpy","title":"Numpy","text":"<ul> <li>Python library</li> <li>High dimension arrays and matrices</li> <li>Mathematical functions</li> </ul> <p><pre><code>import numpy as np\n\n# Creating ndarrays\na = np.zeros(3)\na.shape\na.shape=(3,1)\na = np.ones(5)\na = np.empty(10)\nl = np.linspace(5, 10, 6)\nr = np.array([1,2])    # ndarray from python list\nr = np.array([[1,2],[3,4]])\ntype(r)\n\n# Indexing\nl[0]\nl[0:2]\nl[-1]\nr[:,0]\n\n# Operations on ndarrays\nr_sin = np.sin(r)\nnp.max(r)\nnp.min(r)\nnp.sum(r)\nnp.mean(r)\nnp.std(r)\n\nl &lt; 7\nl[l &lt; 7]\nnp.where(l &lt; 7)\n\np = np.linspace(1, 5, 6)\nq = np.linspace(10, 14, 6)\n\ns = p + q\ns = p * q\ns = p * 10\ns = p + 10\ns = p @ q    # dot product\ns = r.T\n</code></pre> If not installed:</p> <pre><code>pip3 install numpy\n</code></pre>"},{"location":"04_da_vinci/#matplotlib","title":"Matplotlib","text":"<ul> <li>Visualization in python</li> <li>Syntax similar to Matlab</li> </ul> <pre><code>import numpy as np\nfrom matplotlib import pyplot as plt\n\nX = np.linspace(-np.pi, np.pi, 256)\nC, S = np.cos(X), np.sin(X)\n\nplt.plot(X, C)\nplt.plot(X, S)\n\nplt.show()\n</code></pre> <p>If not installed:</p> <pre><code>pip3 install matplotlib\n</code></pre>"},{"location":"04_da_vinci/#practice","title":"Practice","text":""},{"location":"04_da_vinci/#1-dvrk-ros-2-install","title":"1. dVRK ROS 2 install","text":"<p>The da Vinci Surgical System is used to perform minimally invasive surgeries by teleoperation. The da Vinci Research Kit (DVRK) is an open-source hardware and software platform, offers, amongst others, reading and writing all the joints of the da Vinci, and also simulators for each arm. The DVRK software can be built as follows.</p> <ol> <li> <p>Clone the dVRK (da Vinci Reserach Kit) using <code>vcs</code> into a new workspace, then build it:</p> <pre><code>mkdir -p ~/dvrk2_ws/src\ncd ~/dvrk2_ws/src                \nvcs import --input https://raw.githubusercontent.com/jhu-dvrk/dvrk_robot_ros2/main/dvrk.vcs --recursive\ncd ~/dvrk2_ws\ncolcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release   \nsource ~/dvrk2_ws/install/setup.bash\n</code></pre> </li> <li> <p>Add the following line to the end of the <code>.bashrc</code> file:</p> <pre><code>source ~/dvrk2_ws/install/setup.bash\n</code></pre> </li> <li> <p>Run these commands in separate terminals to launch the simulation. Do not forget to push the Home button in the DVRK console.</p> <pre><code># dVRK main console\nros2 run dvrk_robot dvrk_console_json -j ~/dvrk2_ws/install/sawIntuitiveResearchKitAll/share/sawIntuitiveResearchKit/share/console/console-PSM1_KIN_SIMULATED.json\n</code></pre> <pre><code># ROS 2 joint and robot state publishers\nros2 launch dvrk_model dvrk_state_publisher.launch.py arm:=PSM1\n</code></pre> <pre><code># RViz\nros2 run rviz2 rviz2 -d ~/dvrk2_ws/install/dvrk_model/share/dvrk_model/rviz/PSM1.rviz\n</code></pre> <pre><code># rqt_gui\nros2 run rqt_gui rqt_gui\n</code></pre> </li> </ol>"},{"location":"04_da_vinci/#2-psm-subscriber","title":"2. PSM subscriber","text":"<ol> <li> <p>Create a new file named <code>psm_grasp.py</code> in the <code>~/ros2_ws/src/ros2_course/ros2_course</code> folder. Add it to the <code>CMakeLists.txt</code>, as usually.</p> </li> <li> <p>Check the topics and nodes of the simulator using the commands learned earlier (<code>rostopic list</code>, <code>rosrun rqt_graph rqt_graph</code>, etc.). PSM1 publishes the pose of the TCP and the angle of the jaws into the topics below. Subscribe to these topic in <code>psm_grasp.py</code> and store the current values into variables.</p> <pre><code>/PSM1/measured_cp\n/PSM1/jaw/measured_js\n</code></pre> </li> <li> <p>Build and run the node:</p> <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\nros2 run ros2_course psm_grasp \n</code></pre> </li> </ol>"},{"location":"04_da_vinci/#3-move-the-tcp-along-a-linear-trajectory","title":"3. Move the TCP along a linear trajectory","text":"<ol> <li> <p>PSM1 expects commands regarding the pose of the TCP and the angle of the jaws from the topics below. Create publishers to these topic in <code>psm_grasp.py</code>.</p> <pre><code>/PSM1/servo_cp\n/PSM1/jaw/servo_jp\n</code></pre> </li> <li> <p>Implement a method that moves the TCP to the desired position along a linear trajectory. Send the gripper to the position (0.0, 0.05, -0.12), leave the orientation as it is. Let the sampling time dt be 0.01s.</p> <pre><code>def move_tcp_to(self, target, v, dt):\n</code></pre> <p>Tip</p> <p>Use the function <code>np.linspace(start, stop, num)</code> to create the array of t values (T). This function can also be used to create the linear trajectory along the axes x, y, z in separate arrays X, Y and Z.</p> </li> <li> <p>Write a method that can open and close the gripper jaws, also along a linear trajectory.</p> <pre><code>def move_jaw_to(self, target, omega, dt):\n</code></pre> <p></p> </li> </ol>"},{"location":"04_da_vinci/#4-dummy-marker","title":"4. Dummy marker","text":"<ol> <li> <p>Write a node that creates a virtual marker that can be grasped publishing<code>visualization_msgs/Marker</code> messages. Create a new file named <code>dummy_marker.py</code> in the <code>~/catkin_ws/src/ros_course/scripts</code> folder. Add it to the <code>CMakeLists.txt</code>, as usually. Copy the following code into the file <code>dummy_marker.py</code>:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom visualization_msgs.msg import Marker\n\nclass DummyMarker(Node):\n    def __init__(self, position):\n        super().__init__('minimal_publisher')\n        self.position = position\n        self.publisher_ = self.create_publisher(Marker, 'dummy_target_marker', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n        i = 0\n\n    def timer_callback(self):\n        marker = Marker()\n        marker.header.frame_id = 'PSM1_psm_base_link'\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = \"dvrk_viz\"\n        marker.id = self.i\n        marker.type = Marker.SPHERE\n        marker.action = Marker.MODIFY\n        marker.pose.position.x = self.position[0]\n        marker.pose.position.y = self.position[1]\n        marker.pose.position.z = self.position[2]\n        marker.pose.orientation.x = 0.0\n        marker.pose.orientation.y = 0.0\n        marker.pose.orientation.z = 0.0\n        marker.pose.orientation.w = 1.0\n        marker.scale.x = 0.008\n        marker.scale.y = 0.008\n        marker.scale.z = 0.008\n        marker.color.a = 1.0 # Don't forget to set the alpha!\n        marker.color.r = 0.0\n        marker.color.g = 1.0\n        marker.color.b = 0.0;\n\n        self.publisher_.publish(marker)\n        self.i += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    marker_publisher = DummyMarker([-0.05, 0.08, -0.12])\n    rclpy.spin(marker_publisher)\n\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    marker_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> </li> <li> <p>Build and run the node. Visualize the marker in RViz.</p> </li> </ol>"},{"location":"04_da_vinci/#5-grasp-the-marker","title":"5. Grasp the marker","text":"<ol> <li> <p>Subscribe to the topic with the marker position <code>dummy_target_publisher</code> the file <code>psm_grasp.py</code>.</p> </li> <li> <p>Implement a method in <code>psm_grasp.py</code> to grasp the generated marker with PSM1.</p> <p>Note</p> <p>Some values tends to stuck in the simulator. Thus, at the beginning of the program, it is a good idea to reset the arm: <pre><code>#Reset the arm\npsm.move_tcp_to([0.0, 0.0, -0.12], 0.01, 0.01)\npsm.move_jaw_to(0.0, 0.1, 0.01)\n</code></pre></p> </li> </ol>"},{"location":"04_da_vinci/#links","title":"Links","text":"<ul> <li>Download and compile dVRK 2</li> <li>Marker examples</li> <li>Numpy vector magnitude</li> <li>Numpy linspace</li> </ul>"},{"location":"05_git/","title":"05. Versioning, Git","text":""},{"location":"05_git/#lecture","title":"Lecture","text":""},{"location":"05_git/#version-control-git","title":"Version control, Git","text":"<ul> <li>Track changes in a set of files</li> <li>Coordinating work among developers</li> <li>Who made what changes and when</li> <li>Revert back at any time</li> <li>Local and remote repos</li> <li>Take snapshots of files by making a commit</li> </ul>"},{"location":"05_git/#install","title":"Install","text":"<pre><code>sudo apt install git\n</code></pre>"},{"location":"05_git/#basic-commands","title":"Basic commands","text":"<pre><code>git init          # Initialize local git repo\ngit add &lt;file&gt;    # Add file/files to staging area\ngit status        # Check status of working tree and staging area\ngit commit -m \"What I've done\"    # Commit changes in index\ngit push          # Push to remote repository\ngit pull          # Pull latest changes from remote repo\ngit branch &lt;new_branch_name&gt;\ngit checkout &lt;branch_name&gt;\ngit merge &lt;branch_name&gt;   # Merge the branch into the current branch\ngit config --global user.name \"Istvan Szabo\"\ngit config --global user.email \"istvan.szabo@gmail.com\"\n</code></pre> <p>Tip</p> <p>Store personal token: <code>git config --global credential.helper store</code></p> <p>Tip</p> <p>Windows and Linux clock issue: <code>timedatectl set-local-rtc 1 --adjust-system-clock</code></p>"},{"location":"05_git/#github","title":"GitHub","text":"<pre><code>git remote\ngit clone &lt;link&gt;   # Copy repo into a new directory\n\n# Add remote to repository:\ngit remote add origin &lt;link&gt;\ngit push -u origin master\n</code></pre> <p>Some alternatives to GitHub</p> <p>GitLab, BitBucket, Launchpad, Phabricator </p>"},{"location":"05_git/#markdown","title":"Markdown","text":"<ul> <li>Markup language, easy to read</li> <li>Text file \u2192 Formatted document</li> <li>Widespread usag, e.g., blogs, forums, documentations, readme files, GitHub </li> <li>Markdown Cheatsheet</li> </ul>"},{"location":"05_git/#gyakorlat","title":"Gyakorlat","text":""},{"location":"05_git/#0-github-repo-letrehozasa","title":"0: GitHub repo l\u00e9trehoz\u00e1sa","text":"<ol> <li>Inicializ\u00e1ljunk egy lok\u00e1lis git repo-t a <code>ros-course</code> package-ben.</li> <li>Regisztr\u00e1ljunk GitHub-ra, majd hozzunk l\u00e9tre egy private repo-t a <code>ros_course</code> package sz\u00e1m\u00e1ra. \u00c1ll\u00edtsuk be a local repo-ban a remote-ot, majd push-oljuk a package tartalm\u00e1t.</li> </ol>"},{"location":"06_roslaunch/","title":"08. Roslaunch, ROS parameter szerver, Rosbag","text":""},{"location":"06_roslaunch/#lecture","title":"Lecture","text":""},{"location":"06_roslaunch/#roslaunch","title":"Roslaunch","text":"<ul> <li>Launch multiple nodes</li> <li>Also launches ROS master if not running</li> <li>Set parameters</li> <li>XML file format, <code>.launch</code> extension</li> </ul>"},{"location":"06_roslaunch/#example-launch-file","title":"Example launch file","text":"<pre><code>    &lt;!-- dvrk_server.launch --&gt;\n    &lt;!-- Launch the irob dVRK high-level robot controller. After start, it will wait for irob_msgs/Robot actions --&gt;\n\n    &lt;launch&gt;\n        &lt;group ns=\"saf\"&gt;\n\n            &lt;arg name=\"arm_typ\" default=\"PSM2\"/&gt;\n            &lt;arg name=\"arm_name\" default=\"arm_1\"/&gt;\n            &lt;arg name=\"camera_registration_file\" default=\"registration_psm1.yaml\"/&gt;\n\n            &lt;arg name=\"instrument_info_file\" default=\"prograsp_forceps.yaml\"/&gt;\n\n            &lt;include file=\"$(find irob_robot)/config/dvrk_topic_names.xml\" /&gt; \n\n            &lt;node name=\"robot_server_$(arg arm_typ)\" pkg=\"irob_robot\"  type=\"robot_server_dvrk\"\n                                                                                 output=\"screen\"&gt;\n\n                &lt;param name=\"arm_typ\" type=\"string\" value=\"$(arg arm_typ)\" /&gt;\n                &lt;param name=\"arm_name\" type=\"string\" value=\"$(arg arm_name)\" /&gt;\n                &lt;param name=\"home_joint_angles\" type=\"yaml\" value=\"[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\" /&gt;\n\n                &lt;rosparam command=\"load\" \n                        file=\"$(find irob_robot)/config/$(arg camera_registration_file)\"/&gt;\n\n                &lt;rosparam command=\"load\" \n                        file=\"$(find irob_robot)/config/$(arg instrument_info_file)\"/&gt;\n\n            &lt;/node&gt;\n        &lt;/group&gt;\n    &lt;/launch&gt;\n</code></pre>"},{"location":"06_roslaunch/#usage","title":"Usage","text":"<pre><code>    roslaunch package_name file.launch\n    roslaunch irob_robot dvrk_server.launch arm_typ:=PSM1\n</code></pre>"},{"location":"06_roslaunch/#ros-parameter-server","title":"ROS Parameter Server","text":"<ul> <li>Nodes can store and retrieve parameters at runtime</li> <li>Shared dictionary</li> <li>Best use for configuration</li> <li>ROS naming convention</li> <li>Private parameters (~)</li> <li>Available data types:<ul> <li>32-bit integers</li> <li>booleans</li> <li>strings</li> <li>doubles</li> <li>iso8601 dates</li> <li>lists</li> <li>base64-encoded binary data </li> </ul> </li> <li>Useful command: <code>rosparam</code></li> </ul>"},{"location":"06_roslaunch/#python-api","title":"Python API","text":"<pre><code>    # Call AFTER rospy.init_node()\n\n    # Getting parameters\n    global_name = rospy.get_param(\"/global_name\")\n    relative_name = rospy.get_param(\"relative_name\")\n    private_param = rospy.get_param('~private_name')\n    default_param = rospy.get_param('default_param', 'default_value')\n\n    # fetch a group (dictionary) of parameters\n    gains = rospy.get_param('gains')\n    p, i, d = gains['p'], gains['i'], gains['d']\n\n    # Setting parameters\n    # Using rospy and raw python objects\n    rospy.set_param('a_string', 'baz')\n    rospy.set_param('~private_int', 2)\n    rospy.set_param('list_of_floats', [1., 2., 3., 4.])\n    rospy.set_param('bool_True', True)\n    rospy.set_param('gains', {'p': 1, 'i': 2, 'd': 3})\n\n    # Using rosparam and yaml strings\n    rosparam.set_param('a_string', 'baz')\n    rosparam.set_param('~private_int', '2')\n    rosparam.set_param('list_of_floats', \"[1., 2., 3., 4.]\")\n    rosparam.set_param('bool_True', \"true\")\n    rosparam.set_param('gains', \"{'p': 1, 'i': 2, 'd': 3}\")\n\n    rospy.get_param('gains/p') #should return 1\n</code></pre>"},{"location":"06_roslaunch/#roslaunch-api","title":"Roslaunch API","text":"<pre><code>    &lt;param name=\"arm_typ\" type=\"string\" value=\"ECM\" /&gt;\n    &lt;param name=\"publish_frequency\" type=\"double\" value=\"10.0\" /&gt;\n    &lt;rosparam command=\"load\" file=\"FILENAME\" /&gt;\n</code></pre>"},{"location":"06_roslaunch/#yaml","title":"YAML","text":"<ul> <li>\u201cA human friendly data serialization standard for all programming languages\u201d</li> </ul> <pre><code>    # registration_identity.yaml\n    t: [0.0, 0.0, 0.0]\n    R: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]\n</code></pre>"},{"location":"06_roslaunch/#rosbag","title":"Rosbag","text":"<ul> <li>Record and playback ROS topics</li> <li>Command line tool</li> <li>API for C++ and Python</li> </ul> <pre><code>    rosbag record &lt;topic_name&gt;\n    rosbag record --all\n    rosbag play &lt;filename.bag&gt;\n</code></pre>"},{"location":"06_roslaunch/#practice","title":"Practice","text":""},{"location":"06_roslaunch/#1-marker-disk","title":"1: Marker: Disk","text":"<ol> <li> <p>Create a new file named <code>dummy_cylinder.py</code> in the <code>scripts</code> folder. Publish disk shaped Marker with position (0.05, 0.05, -0.15) and radius of 0.1 m. </p> </li> </ol>"},{"location":"06_roslaunch/#2-launchfile-and-params-for-the-markers","title":"2: Launchfile and params for the markers","text":"<ol> <li> <p>Create a new file named <code>dummy_markers.launch</code> in the folder <code>~catkin_ws/src/ros_course/launch</code>. If the folder does not exist, create that as well. Write a launchfile, that launches both dummy marker publisher nodes.</p> </li> <li> <p>Modify the launchfile and the Python scripts so the dummy marker publishers receive the position of the marker as a ROS parameter, that can also be set from the command line (see the example in Chapter 6). Let the position of the markers have default values too, sphere: (-0.05, 0.1, -0.12), disk: (0.05, 0.05, -0.15).</p> </li> <li> <p>Create a YAML file, containing the size and the color of the disk marker. Load those parameters in the Python script through roslaunch.</p> </li> </ol>"},{"location":"06_roslaunch/#3-navigation-around-the-perimeter","title":"3: Navigation around the perimeter","text":"<ol> <li> <p>Create a new launchfile named <code>psm_grasp.launch</code> for the script <code>psm_grasp.py</code>. Let dt, velocity and angular velocity of the jaws be set as ROS parameters.</p> </li> <li> <p>Run <code>psm_grasp.launch</code> with different marker positions.</p> </li> <li> <p>Modify <code>psm_grasp.py</code> so that the TCP moves around the perimeter of the disk marker before grasping the spherical one.</p> </li> </ol>"},{"location":"06_roslaunch/#4-record-with-rosbag","title":"4: Record with rosbag","text":"<ol> <li> <p>While running the program implemented in the previous exercise, record the contents of all topics to a bag file.</p> <pre><code>    rosbag record --all\n</code></pre> </li> <li> <p>Install the package <code>rqt</code>.</p> <pre><code>    sudo apt-get update\n    sudo apt-get install ros-noetic-rqt\n    sudo apt-get install ros-noetic-rqt-common-plugins\n</code></pre> </li> <li> <p>Play back the recorded bag file and echo some of the PSM1's topics (or visualize the coordinates of the PSM TCP using <code>rqt_plot</code>).</p> <pre><code>    rosbag play &lt;filename.bag&gt;\n    rostopic echo /PSM1/measured_cp\n</code></pre> </li> </ol>"},{"location":"06_roslaunch/#hasznos-linkek","title":"Hasznos linkek","text":"<ul> <li>Roslaunch</li> <li>ROS Parameter Server</li> <li>Python API for the ROS Parameter Server</li> <li> tag in roslaunch</li> <li>Rosparam YAML</li> <li>Rosbag</li> <li>rqt_plot</li> </ul>"},{"location":"07_robotics_principles/","title":"07. Kinematics, inverse kinematics. Programming a simulated robot in joint space and task space","text":"<p>Warning</p> <p>ZH2 (Roslaunch, ROS parameter szerver. ROS service. ROS action. Kinematics, inverse kinematics) and project presentation: December 6.</p>"},{"location":"07_robotics_principles/#rehearsal","title":"Rehearsal","text":""},{"location":"07_robotics_principles/#3d-transformations","title":"3D transformations","text":"<ul> <li>Position: 3D offset vector  </li> <li> <p>Orientation: 3 x 3 rotation matrix</p> <ul> <li>further orientation representations: Euler-angles, RPY, angle axis, quaternion</li> </ul> </li> <li> <p>Pose: 4 \u00d7 4 (homogenous) transformation matrix</p> </li> <li>Frame: origin, 3 axes, 3 base vectors, right hand rule</li> <li>Homogenous transformation: rotation and translation in one transfromation<ul> <li>e.g., for the rotation \\(\\mathbf{R}\\) and translation \\(\\mathbf{v}\\):</li> </ul> </li> </ul> \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right] = \\left[\\matrix{r_{1,1} &amp; r_{1,2} &amp; r_{1,3} &amp; v_x\\\\r_{2,1} &amp; r_{2,2} &amp; r_{2,3} &amp; v_y\\\\r_{3,1} &amp; r_{3,2} &amp; r_{3,3} &amp; v_z\\\\\\ 0 &amp; 0 &amp; 0 &amp; 1 }\\right] \\] <ul> <li>Homogenous coordinates: <ul> <li>Vector: extended with 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\)</li> <li>Point: extended by 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\)</li> <li>Applying transfomrations is much easier:</li> </ul> </li> </ul> \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} &amp; \\mathbf{v}\\\\\\mathbf{0} &amp; 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] <ul> <li>Degrees of Freedom (DoF): the number of independent parameters.</li> </ul>"},{"location":"07_robotics_principles/#principles-of-robotics","title":"Principles of robotics","text":"<ul> <li>Robots are built of: segments (or links) \u00e9s joints</li> <li>Task space (or cartesian space):<ul> <li>3D space around us, where the task, endpoint trajectories, obstacles are defined.</li> <li>TCP (Tool Center Point): Frame fixed to the end effector of the robot.</li> <li>Base frame, world frame</li> </ul> </li> <li>Joint space:<ul> <li>Properties or values regarding the joints.</li> <li>Low-level controller.</li> <li>Joint angles, joint velocities, accelerations, torques....</li> </ul> </li> </ul>"},{"location":"07_robotics_principles/#lecture","title":"Lecture","text":""},{"location":"07_robotics_principles/#kinematics-inverse-kinematics","title":"Kinematics, inverse kinematics","text":"<p>Def. Kinematics</p> <p>Calculation of the pose of the TCP from joint angles. (From joint space to task space)</p> <ul> <li>Kinematic model<ul> <li>Denavit--Hartenberg (HD) convention</li> <li>URDF (Unified Robotics Description Format, XML-based)</li> </ul> </li> </ul> <p>If the frames attached to each segment are named \\(base, 1, 2, 3, ..., TCP\\), transformations between two neighboring segments \\(i\\) and \\(i+1\\)---dependent on the angle of the joint enclosed by them---are named \\(T_{i+1,i}(q_{i+1})\\), the transformation from the base frame to the TCP can be calculated as follows for a robot with \\(n\\) joints:</p> \\[      T_{TCP,base}(q_1, \\cdots, q_n) = T_{TCP,n-1}(q_{n}) \\cdot T_{n-1,n-2}(q_{n-1}) \\cdots T_{2,1}(q_2) \\cdot T_{1,base}(q_1) \\cdot base \\] <p>Def. Inverse kinematics</p> <p>Calculation of the joint angles in order to reach desired (or any) TCP pose. (From task space to joint space)</p>"},{"location":"07_robotics_principles/#differential-inverse-kinematics","title":"Differential inverse kinematics","text":"<p>Def. Differential inverse kinematics</p> <p>How to change the joint angles to achieve the desired small change in TCP pose (including rotation and translation).</p> <ul> <li> <p>Jacobian matrix (Jacobian): The Jacobian matrix of a vector-valued function of several variables is the matrix of all its first-order partial derivatives.</p> \\[ \\mathbf{J} = \\left[\\matrix{\\frac{\\partial x_1}{\\partial q_1} &amp; \\frac{\\partial x_1}{\\partial q_2} &amp;\\frac{\\partial x_1}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_1}{\\partial q_n} \\\\ \\frac{\\partial x_2}{\\partial q_1} &amp; \\frac{\\partial x_2}{\\partial q_2} &amp;\\frac{\\partial x_2} {\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_2}{\\partial q_n} \\\\ \\frac{\\partial x_3}{\\partial q_1} &amp; \\frac{\\partial x_3}{\\partial q_2} &amp;\\frac{\\partial x_3}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_3}{\\partial q_n} \\\\ \\vdots &amp;\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots \\\\ \\frac{\\partial x_m}{\\partial q_1} &amp; \\frac{\\partial x_m}{\\partial q_2} &amp;\\frac{\\partial x_m}{\\partial q_3} &amp; \\dots &amp;\\frac{\\partial x_m}{\\partial q_n} \\\\}\\right] \\] </li> <li> <p>Jacobian matrix in robotics: defines the relationship between the joint velocities and the velocity of the TCP:</p> \\[ \\left[\\matrix{\\mathbf{v} \\\\ \\mathbf{\\omega}}\\right] =\\mathbf{J}(\\mathbf{q})\\cdot \\mathbf{\\dot{q}} \\] </li> </ul> <p>If \\(\\Delta{t}\\) is small enough:</p> <pre><code>$$\n\\left[\\matrix{{\\Delta\\mathbf{r}}\\over{\\Delta{t}} \\\\ {\\Delta\\mathbf{\\theta}}\\over{\\Delta{t}}}\\right] =\\mathbf{J}(\\mathbf{q})\\cdot \\Delta{\\mathbf{q}\\over{\\Delta{t}}\n$$\n</code></pre>"},{"location":"07_robotics_principles/#differential-inverse-kinematics-using-jacobian-inverse","title":"Differential inverse kinematics using Jacobian inverse","text":"<ol> <li>Calculate the difference of the desired and the current position: \\(\\Delta\\mathbf{r} = \\mathbf{r}_{desired} - \\mathbf{r}_0\\)</li> <li>Calculate the rotation between the current orientation and the desired orientation: \\(\\Delta\\mathbf{R} = \\mathbf{R}_{desired}\\mathbf{R}_{0}^{T}\\), majd konvert\u00e1ljuk \u00e1t axis angle reprezent\u00e1ci\u00f3ba \\((\\mathbf{t},\\phi)\\)</li> <li>Calculate \\(\\Delta\\mathbf{ q}=\\mathbf{J}^{-1}(\\mathbf{q_0})\\cdot \\left[\\matrix{k_1 \\cdot \\Delta\\mathbf{r} \\\\ k_2 \\cdot \\phi \\cdot \\mathbf{t}}\\right]\\), where the inverse could be substituted by pseudo-inverse or transpose</li> <li>Change joint angles: \\(\\mathbf{q}_{better} = \\mathbf{q}_{0} + \\Delta\\mathbf{q}\\)</li> </ol>"},{"location":"07_robotics_principles/#practice","title":"Practice","text":""},{"location":"07_robotics_principles/#1-install-rrr-arm","title":"1: Install rrr-arm","text":"<ol> <li> <p>Install dependencies:</p> <pre><code>sudo apt update\nsudo apt-get install ros-noetic-effort-controllers\nsudo apt-get install ros-noetic-position-controllers\nsudo apt-get install ros-noetic-gazebo-ros-pkgs \nsudo apt-get install ros-noetic-gazebo-ros-control\nsudo apt-get install ros-noetic-gazebo-ros\npip3 install kinpy \nrosdep update\n</code></pre> <p>Tip</p> <p>We will use the package <code>kinpy</code> to calculate forward kinematics. Download the source of the package <code>kinpy</code> and study the API: https://pypi.org/project/kinpy/ </p> </li> <li> <p>Clone and build the repo:</p> <pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/Robotawi/rrr-arm.git\ncd ..\ncatkin build\n</code></pre> </li> <li> <p>Launch the simulator and move the arm:</p> <pre><code>roslaunch rrr_arm view_arm_gazebo_control_empty_world.launch\n</code></pre> <pre><code>rostopic pub /rrr_arm/joint1_position_controller/command  std_msgs/Float64 \"data: 1.0\" &amp;    rostopic pub /rrr_arm/joint2_position_controller/command  std_msgs/Float64 \"data: 1.0\" &amp; rostopic pub /rrr_arm/joint3_position_controller/command  std_msgs/Float64 \"data: 1.5\" &amp; rostopic pub /rrr_arm/joint4_position_controller/command std_msgs/Float64 \"data: 1.5\"\n</code></pre> <p>Tip</p> <p>The simulator might raise errors like \"No p gain specified for pid...\", but those can be ignored as won't cause any issues.</p> </li> <li> <p>Build the URDF file describes the robot:</p> <pre><code>cd ~/catkin_ws/src/rrr-arm/urdf\nrosrun xacro xacro rrr_arm.xacro &gt; rrr_arm.xacro.urdf\n</code></pre> </li> </ol>"},{"location":"07_robotics_principles/#2-move-the-arm-in-joint-space","title":"2: Move the arm in joint space","text":"<ol> <li> <p>Create a new file named <code>rrr_arm_node</code> in the <code>scripts</code> folder. Add it to the <code>CMakeLists.txt</code>, as usual. Subscribe to the topic which publishes the joint angles (configuration) of the robot. Create publishers to the 4 topics setting the joint angles of the arm. Use the previous Python scripts as a template.</p> <p>Warning</p> <p>Gazebo and <code>kinpy</code> organized the joints in different orders:  1. [gripper_joint_1, gripper_joint_2, joint_1, joint_2, joint_3, joint_4] - topic <code>/rrr_arm/joint_states</code> - method <code>kp.jacobian.calc_jacobian(...)</code></p> <p>2. [joint_1, joint_2, joint_3, joint_4, gripper_joint_1, gripper_joint_2] - method <code>chain.forward_kinematics(...)</code> - method <code>chain.inverse_kinematics(...)</code></p> </li> <li> <p>Send the arm to the configuration [1.0, 1.0, 1.5, 1.5].</p> </li> </ol>"},{"location":"07_robotics_principles/#3-kinematic-task","title":"3. Kinematic task","text":"<ol> <li> <p>Import <code>kinpy</code> and read the URDF of the robot:</p> <pre><code>import kinpy as kp\n\nchain = kp.build_serial_chain_from_urdf(open(\"/home/&lt;USERNAME&gt;/catkin_ws/src/rrr-arm/urdf/rrr_arm.xacro.urdf\").read(), \"gripper_frame_cp\")\nprint(chain)\nprint(chain.get_joint_parameter_names())\n</code></pre> </li> <li> <p>Calculate the TCP pose in the current configuration using <code>kinpy</code>. The example at https://pypi.org/project/kinpy/ is wrong, use the following example:</p> <pre><code>    th1 = np.random.rand(2)\n    tg = chain.forward_kinematics(th1)\n    th2 = chain.inverse_kinematics(tg)\n    self.assertTrue(np.allclose(th1, th2, atol=1.0e-6))\n</code></pre> </li> </ol>"},{"location":"07_robotics_principles/#4-inverse-kinematics-using-jacobian-inverse","title":"4: Inverse kinematics using Jacobian inverse","text":"<p>Implement a method calculating inverse kinematics using Jacobian inverse for the robot. Ignore the orientation for now. Move the TCP to position <code>(0.59840159, -0.21191189,  0.42244937)</code>.</p> <ol> <li> <p>Write a while loop stopping if the length of <code>delta_r</code> is below threshold or <code>rospy.is_shutdown()</code>.</p> </li> <li> <p>Calculate the difference of the desired and current TCP positions (<code>delta_r</code>). Scale by constant <code>k_1</code>.</p> </li> <li> <p>Let <code>phi_dot_t</code> be <code>[0.0, 0.0, 0.0]</code> (ignore the orientation).</p> </li> <li> <p>Concatenate <code>delta_r</code> and <code>phi_dot_t</code>-t.</p> </li> <li> <p>Calculate the Jacobian matrix in the current configuration using the method <code>kp.jacobian.calc_jacobian(...)</code>.</p> </li> <li> <p>Calculate the pseudo inverse of the Jacobian using <code>np.linalg.pinv(...)</code>.</p> </li> <li> <p>Calculate <code>delta_q</code>, use the <code>.dot(...)</code> method from Numpy.</p> </li> <li> <p>Increase the joint angles by <code>delta_q</code>.</p> </li> </ol>"},{"location":"07_robotics_principles/#bonus-exercise-inverse-kinematics-with-orientation","title":"Bonus exercise: Inverse kinematics with orientation","text":"<p>Extend the previous exercise by calculating both the TCP position and orientation.</p>"},{"location":"07_robotics_principles/#useful-links","title":"Useful links","text":"<ul> <li>rrr-arm model</li> <li>https://pypi.org/project/kinpy/</li> <li>https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation</li> <li>https://www.rosroboticslearning.com/jacobian</li> </ul>"},{"location":"08_sensory_data/","title":"10. Szenzoros adatok gy\u0171jt\u00e9se \u00e9s feldolgoz\u00e1sa","text":""},{"location":"08_sensory_data/#gyakorlat","title":"Gyakorlat","text":"<p>Thing may change here...</p> <p>Ezt a gyakorlatot lehet, hogy le fogjuk cser\u00e9lni.</p>"},{"location":"08_sensory_data/#1-leo-rover","title":"1: Leo rover","text":"<ol> <li> <p>Install\u00e1ljuk a Leo rover ROS package-eit:</p> <pre><code>sudo apt update\nsudo apt install ros-noetic-leo*\n</code></pre> </li> <li> <p>A http://wiki.ros.org/leo_gazebo le\u00edr\u00e1s seg\u00edts\u00e9g\u00e9vel ind\u00edtsuk el a gazebo szimul\u00e1tort a Mars landscape-pel.</p> </li> <li> <p>Ind\u00edtsunk teleop node-ot, \u00e9s mozgassuk meg a robotot.</p> </li> </ol>"},{"location":"08_sensory_data/#2-kave-a-marson-kepek-rogzitese","title":"2: K\u00e1v\u00e9 a Marson -- k\u00e9pek r\u00f6gz\u00edt\u00e9se","text":"<p>Warning</p> <p>A Mars rover k\u00e9pet k\u00fcld\u00f6tt egy k\u00fcl\u00f6n\u00f6s, k\u00e1v\u00e9s b\u00f6gr\u00e9nek t\u0171n\u0151 t\u00e1rgyr\u00f3l! A feladat, hogy ford\u00edtsuk a rovert a b\u00f6gre fel\u00e9, majd k\u00f6zel\u00edts\u00fck meg, hogy r\u00e9szletesen megvizsg\u00e1lhassuk.</p> <p></p> <ol> <li> <p>Ind\u00edtsuk el a Gazebo-t:</p> <pre><code>    gazebo\n</code></pre> </li> <li> <p>Az <code>insert</code> panelen keress\u00fck ki a <code>googleresearch/models/cole_hardware_mug_classic_blue</code> modellt, majd helyezz\u00fck el a szimul\u00e1ci\u00f3ban. Ez az\u00e9rt kell, hogy k\u00e9s\u0151bb meglegyen a b\u00f6gre modellje a f\u00e1ljrendszer\u00fcnkben.</p> </li> <li> <p>Z\u00e1rjuk be a Gazebo-t</p> </li> <li> <p>T\u00f6lts\u00fck le a <code>leo_masryard_coffee.launch</code> \u00e9s a <code>marsyard_coffe.world</code> f\u00e1jlokat, majd m\u00e1soljuk be rendre a <code>catkin_ws/src/ros_course/launch</code> \u00e9s <code>catkin_ws/src/ros_course/worlds</code> mapp\u00e1kba.</p> </li> <li> <p>A <code>.world</code> f\u00e1jlokban \u00edrjuk \u00e1t a <code>/home/tamas/.ignition/fuel/fuel...</code> el\u00e9r\u00e9si utakat (f\u00e1jlonk\u00e9nt 2x) a saj\u00e1tunkra.</p> </li> <li> <p>Ind\u00edtsuk el a szimul\u00e1tort:</p> <pre><code>    roslaunch ros_course leo_marsyard_coffee.launch\n</code></pre> </li> <li> <p>Ind\u00edtsuk el a teleopot \u00e9s az <code>rqt_image_view</code>-t:</p> <pre><code>    rosrun leo_teleop key_teleop\n    ```\n\n```bash\n    rosrun rqt_image_view rqt_image_view\n</code></pre> <p>Tip</p> <p>Ha a szimul\u00e1tor futtat\u00e1sa t\u00fals\u00e1gosan megterhel\u0151 a PC sz\u00e1m\u00e1ra, dolgozhatunk a terrain n\u00e9lk\u00fcli <code>leo_gazebo_coffee.launch</code> \u00e9s <code>gazebo_coffe.world</code> f\u00e1jlokkal is.</p> </li> <li> <p>Ments\u00fcnk le egy-egy k\u00e9pet, amin l\u00e1that\u00f3, illetve nem l\u00e1that\u00f3 a k\u00e1v\u00e9s b\u00f6gre. </p> </li> </ol>"},{"location":"08_sensory_data/#3-kave-a-marson-offline-kepfeldolgozas","title":"3: K\u00e1v\u00e9 a Marson -- offline k\u00e9pfeldolgoz\u00e1s","text":"<ol> <li> <p>\u00cdrjunk Python szkriptet, amely beolvassa \u00e9s megjelen\u00edti a lementett k\u00e9peket.</p> </li> <li> <p>Sz\u00edn alap\u00fa szegment\u00e1l\u00e1ssal (vagy b\u00e1rhogy m\u00e1shogy) szegment\u00e1ljuk a k\u00e1v\u00e9s b\u00f6gr\u00e9t.</p> </li> <li> <p>Hat\u00e1rozzuk meg a b\u00f6gre k\u00f6z\u00e9ppontj\u00e1t k\u00e9pi koordin\u00e1t\u00e1kban.</p> </li> <li> <p>A szegment\u00e1l\u00e1s zaja gondot okozhat, pr\u00f3b\u00e1ljuk meg lesz\u0171rni.</p> </li> </ol>"},{"location":"08_sensory_data/#4-kave-a-marson-online-perception-node","title":"4: K\u00e1v\u00e9 a Marson -- online perception node","text":"<ol> <li> <p>Iratkozzunk fel a <code>/camera/image_raw</code> topicra, majd a <code>cv.imshow()</code> f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9val jelen\u00edts\u00fck meg a kapott k\u00e9peket.</p> </li> <li> <p>Dolgozzuk be a m\u0171k\u00f6d\u0151 computer vision algoritmusunkat egy ROS node-ba.</p> </li> <li> <p>Publik\u00e1ljuk \u00faj topicban a detekt\u00e1lt b\u00f6gre k\u00f6z\u00e9ppontj\u00e1nak k\u00e9pi koordin\u00e1t\u00e1t. Haszn\u00e1lhatjuk pl. az Int32MultiArray, Point2D t\u00edpusokat, vagy defini\u00e1lhatunk saj\u00e1tot (k\u00e9s\u0151bb sz\u00fcks\u00e9g lesz a b\u00f6gre m\u00e9ret\u00e9re is).</p> </li> <li> <p>B\u00f3nusz: publik\u00e1ljuk a maszkot \u00e9s a maszkolt k\u00e9pet egy-egy Image topicban</p> </li> </ol>"},{"location":"08_sensory_data/#5-kave-a-marson-operation-logic-node","title":"5: K\u00e1v\u00e9 a Marson -- operation logic node","text":"<ol> <li> <p>\u00cdrjunk \u00faj ROS node-ot, amely fogadja a perception node \u00fczeneteit, illetve k\u00e9pes a rover mozg\u00e1s\u00e1nak ir\u00e1ny\u00edt\u00e1s\u00e1ra.</p> </li> <li> <p>Forgassuk a rovert egy helyben, am\u00edg a b\u00f6gre a k\u00e9p k\u00f6zep\u00e9re nem ker\u00fcl.</p> </li> <li> <p>K\u00f6zel\u00edts\u00fck meg a b\u00f6gr\u00e9t annyira, hogy a l\u00e1tsz\u00f3lagos m\u00e9rete a k\u00e9p m\u00e9ret\u00e9nek 50%-\u00e1t el nem \u00e9ri.</p> </li> <li> <p>Ments\u00fcnk le k\u00e9pet a gyan\u00fas objektumr\u00f3l.</p> </li> </ol>"},{"location":"08_sensory_data/#51-bonusz","title":"5+1: B\u00f3nusz","text":"<ol> <li> <p>N\u00e9zz\u00fcnk sz\u00e9t Gazebo-ban a beilleszthet\u0151 modellek k\u00f6z\u00f6tt (<code>insert</code> panel) \u00e9s v\u00e1lasszunk egyet, amely valamilyen m\u00e1s m\u00f3dszerrel detekt\u00e1lhat\u00f3 a kamera k\u00e9p\u00e9n (pl. template matching).</p> </li> <li> <p>M\u00f3dos\u00edtsuk \u00fagy a node-okat, hogy ezt az objektumot k\u00f6zel\u00edtse meg a rover.</p> <p>Figyelem!</p> <p>Az \u00f3ra v\u00e9g\u00e9n a forr\u00e1sk\u00f3dokat mindenkinek fel kell t\u00f6lteni Moodle-re egy zip arch\u00edvumba csomagolva!</p> </li> </ol>"},{"location":"08_sensory_data/#hasznos-linkek","title":"Hasznos linkek","text":"<ul> <li>http://wiki.ros.org/leo_gazebo</li> <li>http://wiki.ros.org/cv_bridge/Tutorials/ConvertingBetweenROSImagesAndOpenCVImagesPython</li> <li>https://realpython.com/python-opencv-color-spaces/</li> <li>https://stackoverflow.com/questions/59164192/how-to-find-the-contour-of-a-blob-using-opencv-python</li> </ul>"},{"location":"projects/","title":"Projects","text":""},{"location":"projects/#challenge-levels-and-grades","title":"Challenge levels and grades","text":"<p>Projects can be completed at three Challenge levels. The Challenge level determines the  best grade that can be received to the project! </p> Challenge level Best grade Basic 3 Advanced 4 Epic 5 <p>Tip</p> <p>The projects are defined in a way that it is recommended to tart with the Basic level, and then gradually work towards Epic.</p> <p>The projects are graded based on the follwoing aspects:</p> <ul> <li>Proved to be the student's own work</li> <li>Running results valid output</li> <li>Usage of versioning, usage of GitHub/GitLab/other repository</li> <li>Grading: <ul> <li>completeness of the soultion</li> <li>proper ROS communication</li> <li>proper structure of the program</li> <li>quality of implementation</li> <li>documentation quality</li> </ul> </li> </ul>"},{"location":"projects/#schedule","title":"Schedule","text":"Week Date Event 2. szept. 13 Announcement of project topics. 8. okt. 25 Project milestone. 14. nov. 6 Project presentations."},{"location":"projects/#grading","title":"Grading","text":"<p>Personal attendance on the classes is mandatory (min 70%).</p> <p>To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again.</p> <p>Grade</p> <p>\\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) </p>"},{"location":"projects/#project-topics","title":"Project topics","text":""},{"location":"projects/#1-platypous","title":"1. PlatypOUs","text":""},{"location":"projects/#11-platypous-path-following","title":"1.1. PlatypOUs path following","text":"<ul> <li>Basic: Simulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system for path follwoing in the simulator, using any sensor of the robot (e.g., driving next to the wall with given distance using LIDAR).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#12-platypous-obstacle-avoidance","title":"1.2. PlatypOUs obstacle avoidance","text":"<ul> <li>Basic: SSimulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system to detect obstacle. Calculation and execution of a trajectory avoiding the obstacle in the simulator, using any sensor of the robot.</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#13-platypous-object-follwoing","title":"1.3. PlatypOUs object follwoing","text":"<ul> <li>Basic: Simulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS system to detect an object and follow it in the simulator, using any sensor of the robot(e.g., visual servoing).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#14-platypous-action-library","title":"1.4. PlatypOUs action library","text":"<ul> <li>Basic: Simulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot.</li> <li>Advanced: Implementation of a ROS action library containing simple actions and their execution (e.g., push object, move to object, turn around).</li> <li>Epic: Implementation and testing on the real robot/impress me!</li> </ul>"},{"location":"projects/#2-ambf","title":"2. AMBF","text":""},{"location":"projects/#21-ros-of-a-da-vinci-robot-in-the-ambf-simulator","title":"2.1. ROS of a da Vinci robot in the AMBF simulator","text":"<ul> <li>Basic: Simulator setup, controlling the robot in joint space and task space (IK is implemented in AMBF) from ROS using the topic from CRTK.</li> <li>Advanced: Object detection in the Peg transfer puzzle.</li> <li>Epic: Autonomous manipulation in Peg transfer/implress me!</li> </ul>"},{"location":"projects/#22-ros-integration-of-a-kuka-robot-in-the-ambf-simulator","title":"2.2. ROS integration of a KUKA robot in the AMBF simulator","text":"<ul> <li>Basic: Simulator setup, controlling the robot in joint space from ROS.</li> <li>Advanced: Controlling the robot in task space, IK.</li> <li>Epic: Trajectory planning.</li> </ul>"},{"location":"projects/#23-ros-integration-of-a-pr2-humanoid-robot-in-the-ambf-simulator","title":"2.3. ROS integration of a PR2 humanoid robot in the AMBF simulator","text":"<ul> <li>Basic: Simulator setup, controlling the robot in joint space from ROS.</li> <li>Advanced: Controlling the robot in task space, IK.</li> <li>Epic: Trajectory planning/Navigation/Manipulation.</li> </ul>"},{"location":"projects/#x-custom-topic","title":"X. Custom topic","text":"<p>Based on discussion.</p>"},{"location":"projects/#links","title":"Links","text":"<ul> <li>Gazebo ROS packages</li> <li>PlatypOUs</li> <li>AMBF</li> <li>My fork of AMBF</li> <li>CRTK topics</li> <li>Navigation stack</li> <li>Paper on LiDAR SLAM</li> <li>Paper on vSLAM</li> <li>Paper on Visual Servoing Mobile Robot</li> </ul>"}]}