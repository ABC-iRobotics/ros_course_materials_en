{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Course Information Course Supervisor Dr. P\u00e9ter Galambos peter.galambos@irob.uni-obuda.hu Teachers Tam\u00e1s Levendovics tamas.levendovics@irob.uni-obuda.hu Borsa D\u00e9t\u00e1r detar.borsa@gmail.com Course Requirements Project Proved to be the student's own work Running results valid output Grading: completeness of the soultion, proper ROS communication, proper structure of the program, quality of implementation, documentation Grading Personal attendance on the classes is mandatory (min 70%). To pass the course, Tests and the Project must be passed (grade 2). Test retake is on the 14th week of the semester. Grade \\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) Schedule Week Date Topic Test 1. Sept 13 Requirements. ROS introduction. Setup the development environment. Lab tour. - 2. Sept 20 Setup the development environment. Linux principles. ROS principles. Running examples. ROS package. Basics of ROS communication, implementation of publisher and subscriber. Project topic announcements. 3. Sept 27 Break - 4. Oct 4 Python principles. Practicing ROS communication, solving examples. - 5. Oct 11 Principles of robotics. Programming a da Vinci surgical robot in simulated environment I. - 6. Oct 18 Principles of robotics. Programming a da Vinci surgical robot in simulated environment II. - 7. Oct 25 Project labor I. Test 1 8. Nov 1 Break - 9. Nov 8 ROS 2 Launch, Param, Bag - 10. Nov 15 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space I. - 11. Nov 22 Break - 12. Nov 29 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space II. - 13. Dec 6 Versioning, Git. Project labor II. Test 2 14. Dec 13 Project presentations. Test retake 14+1. ? - Mid-term replacement Warning The schedule may change during the semester! Antal Bejczy Center for Intelligent Robotics (BARK/IROB) https://irob.uni-obuda.hu irob-saf (iRob Surgical Automation Framework) https://github.com/ABC-iRobotics/irob-saf PlatypOUs https://github.com/ABC-iRobotics/PlatypOUs-Mobile-Robot-Platform","title":"Home"},{"location":"#course-information","text":"","title":"Course Information"},{"location":"#course-supervisor","text":"Dr. P\u00e9ter Galambos peter.galambos@irob.uni-obuda.hu","title":"Course Supervisor"},{"location":"#teachers","text":"Tam\u00e1s Levendovics tamas.levendovics@irob.uni-obuda.hu Borsa D\u00e9t\u00e1r detar.borsa@gmail.com","title":"Teachers"},{"location":"#course-requirements","text":"","title":"Course Requirements"},{"location":"#project","text":"Proved to be the student's own work Running results valid output Grading: completeness of the soultion, proper ROS communication, proper structure of the program, quality of implementation, documentation","title":"Project"},{"location":"#grading","text":"Personal attendance on the classes is mandatory (min 70%). To pass the course, Tests and the Project must be passed (grade 2). Test retake is on the 14th week of the semester. Grade \\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\)","title":"Grading"},{"location":"#schedule","text":"Week Date Topic Test 1. Sept 13 Requirements. ROS introduction. Setup the development environment. Lab tour. - 2. Sept 20 Setup the development environment. Linux principles. ROS principles. Running examples. ROS package. Basics of ROS communication, implementation of publisher and subscriber. Project topic announcements. 3. Sept 27 Break - 4. Oct 4 Python principles. Practicing ROS communication, solving examples. - 5. Oct 11 Principles of robotics. Programming a da Vinci surgical robot in simulated environment I. - 6. Oct 18 Principles of robotics. Programming a da Vinci surgical robot in simulated environment II. - 7. Oct 25 Project labor I. Test 1 8. Nov 1 Break - 9. Nov 8 ROS 2 Launch, Param, Bag - 10. Nov 15 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space I. - 11. Nov 22 Break - 12. Nov 29 Kinematics, inverse kinematics, programming a simulated robot arm in joint space and task space II. - 13. Dec 6 Versioning, Git. Project labor II. Test 2 14. Dec 13 Project presentations. Test retake 14+1. ? - Mid-term replacement Warning The schedule may change during the semester!","title":"Schedule"},{"location":"#antal-bejczy-center-for-intelligent-robotics-barkirob","text":"https://irob.uni-obuda.hu","title":"Antal Bejczy Center for Intelligent Robotics (BARK/IROB)"},{"location":"#irob-saf","text":"(iRob Surgical Automation Framework) https://github.com/ABC-iRobotics/irob-saf","title":"irob-saf"},{"location":"#platypous","text":"https://github.com/ABC-iRobotics/PlatypOUs-Mobile-Robot-Platform","title":"PlatypOUs"},{"location":"01_intro/","text":"01. Introduction Robot Operating System (ROS) introduction The definition of robot Joseph Engelberger, pioneer in industrial robotics: \"I can't define a robot, but I know one when I see one.\" Wikipedia: \"A robot is a machine\u2014especially one programmable by a computer\u2014 capable of carrying out a complex series of actions automatically. Robots can be guided by an external control device or the control may be embedded within. Robots may be constructed on the lines of human form, but most robots are machines designed to perform a task with no regard to their aesthetics.\" ISO 8373:2012 Robots and robotic devices \u2013 Vocabulary, FDIS 2012: \"A robot is an actuated mechanism programmable in two or more axes with a degree of autonomy, moving within its environment, to perform intended tasks.\" Rodney Brooks, Founder and CTO, Rethink Robotics: \"A robot is some sort of device, wich has sensors those sensors the world, does some sort of computation, decides on an action, and then does that action based on the sensory input, which makes some change out in the world, outside its body. Comment: the part \"make some change outside its body\" discriminates a washing machine from e.g. a Roomba.\" Tam\u00e1s Haidegger, Encyclopedia of Robotics : \"A robot is a complex mechatronic system enabled with electronics, sensors, actuators and software, executing tasks with a certain degree of autonomy. It may be pre-programmed, teleoperated or carrying out computations to make decisions.\" What is ROS? Open-source, robotics themed middleware Modularity, reusability (drivers, algorithms, libraries, ...) Hardware abstraction, ROS API C++ \u00e9s Python support Ubuntu Linux (except ROS 2) Great community History Mid 2000s, Stanford: robotics themed, flexible, dynamic framework for prototype development 2007, Willow Garage: incubation, the core of ROS under BSD license Spread in robotics reserach, PR2 2012: Industrial robotics, ROS-Industrial 2017: ROS 2 Development system build -- homework Recommended environment: Ubuntu 22.04 ROS2 Humble IDE: QtCreator ROS 2 Humble Hawksbill Setup locale. ```bash locale # check for UTF-8 sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings ``` --- ROS 2 Humble install sudo apt install software-properties-common sudo add-apt-repository universe sudo apt update sudo apt install curl sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( . /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update sudo apt upgrade sudo apt install ros-humble-desktop sudo apt install ros-dev-tools Test the new ROS 2 install: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py talker The source command is responsible for setting the environment variables, which must be specified each time a new terminal window is opened. This command can be inserted at the end of the ~/.bashrc file, which is run every time a terminal window is opened, so you don't have to type it every time (ROS 2 will be the default): echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc Tov\u00e1bbi csomagok We will also need the following packages during the semester, so these should be installed as well: sudo apt install libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev python3-osrf-pycommon libasound2-dev libgl1-mesa-dev xorg-dev python3-vcstool python3-colcon-common-extensions python3-pykdl python3-pyudev libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev libbluetooth-dev ros-humble-joint-state-publisher* ros-humble-xacro gfortran-9 IDE QtCreator Currently, one of the most widely used IDEs for developing ROS packages is QtCreator, for which a ROS plugin has been developed. The installer is available at the link below. You should use the \"18.04 offline installer\", it also works on Ubuntu 22.04. https://ros-qtc-plugin.readthedocs.io/en/latest/_source/How-to-Install-Users.html Once downloaded, the IDE can be installed using the command below (it is important to put cd in the download location): chmod +x qtcreator-ros-bionic-latest-offline-installer.run sudo ./qtcreator-ros-bionic-latest-offline-installer.run When the installer asks you where to install it, change it to e.g. /home/<USER>/QtCreator . If you put it in root, you will not be able to run it. After installation, look for `Qt Creator (4.9.2)'. CLion CLion has a high level of ROS integration, and its use is most recommended for this course. A free student license can be obtained at https://www.jetbrains.com/community/education/#students After installation, browse to the file /var/lib/snapd/desktop/applications/clion_clion.desktop . Copy the appropriate line here so that the IDE will use the environment set by the terminal: Exec = bash -i -c \"/snap/bin/clion\" %f Visual Studio Microsoft Visual Studio also supports source code for ROS, this IDE can also be used during the semester. Suggestion Install Terminator terminal emulator: sudo apt update sudo apt install terminator Links https://www.ros.org/ ROS 2 Humble installation QtCreator + ROS plugin IROB virtual tour","title":"1. Introduction"},{"location":"01_intro/#01-introduction","text":"","title":"01. Introduction"},{"location":"01_intro/#robot-operating-system-ros-introduction","text":"","title":"Robot Operating System (ROS) introduction"},{"location":"01_intro/#the-definition-of-robot","text":"Joseph Engelberger, pioneer in industrial robotics: \"I can't define a robot, but I know one when I see one.\" Wikipedia: \"A robot is a machine\u2014especially one programmable by a computer\u2014 capable of carrying out a complex series of actions automatically. Robots can be guided by an external control device or the control may be embedded within. Robots may be constructed on the lines of human form, but most robots are machines designed to perform a task with no regard to their aesthetics.\" ISO 8373:2012 Robots and robotic devices \u2013 Vocabulary, FDIS 2012: \"A robot is an actuated mechanism programmable in two or more axes with a degree of autonomy, moving within its environment, to perform intended tasks.\" Rodney Brooks, Founder and CTO, Rethink Robotics: \"A robot is some sort of device, wich has sensors those sensors the world, does some sort of computation, decides on an action, and then does that action based on the sensory input, which makes some change out in the world, outside its body. Comment: the part \"make some change outside its body\" discriminates a washing machine from e.g. a Roomba.\" Tam\u00e1s Haidegger, Encyclopedia of Robotics : \"A robot is a complex mechatronic system enabled with electronics, sensors, actuators and software, executing tasks with a certain degree of autonomy. It may be pre-programmed, teleoperated or carrying out computations to make decisions.\"","title":"The definition of robot"},{"location":"01_intro/#what-is-ros","text":"Open-source, robotics themed middleware Modularity, reusability (drivers, algorithms, libraries, ...) Hardware abstraction, ROS API C++ \u00e9s Python support Ubuntu Linux (except ROS 2) Great community","title":"What is ROS?"},{"location":"01_intro/#history","text":"Mid 2000s, Stanford: robotics themed, flexible, dynamic framework for prototype development 2007, Willow Garage: incubation, the core of ROS under BSD license Spread in robotics reserach, PR2 2012: Industrial robotics, ROS-Industrial 2017: ROS 2","title":"History"},{"location":"01_intro/#development-system-build-homework","text":"Recommended environment: Ubuntu 22.04 ROS2 Humble IDE: QtCreator","title":"Development system build -- homework"},{"location":"01_intro/#ros-2-humble-hawksbill","text":"Setup locale. ```bash locale # check for UTF-8 sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings ``` --- ROS 2 Humble install sudo apt install software-properties-common sudo add-apt-repository universe sudo apt update sudo apt install curl sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( . /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update sudo apt upgrade sudo apt install ros-humble-desktop sudo apt install ros-dev-tools Test the new ROS 2 install: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py talker The source command is responsible for setting the environment variables, which must be specified each time a new terminal window is opened. This command can be inserted at the end of the ~/.bashrc file, which is run every time a terminal window is opened, so you don't have to type it every time (ROS 2 will be the default): echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc","title":"ROS 2 Humble Hawksbill"},{"location":"01_intro/#tovabbi-csomagok","text":"We will also need the following packages during the semester, so these should be installed as well: sudo apt install libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev python3-osrf-pycommon libasound2-dev libgl1-mesa-dev xorg-dev python3-vcstool python3-colcon-common-extensions python3-pykdl python3-pyudev libxml2-dev libraw1394-dev libncurses5-dev qtcreator swig sox espeak cmake-curses-gui cmake-qt-gui git subversion gfortran libcppunit-dev libqt5xmlpatterns5-dev libbluetooth-dev ros-humble-joint-state-publisher* ros-humble-xacro gfortran-9","title":"Tov\u00e1bbi csomagok"},{"location":"01_intro/#ide","text":"QtCreator Currently, one of the most widely used IDEs for developing ROS packages is QtCreator, for which a ROS plugin has been developed. The installer is available at the link below. You should use the \"18.04 offline installer\", it also works on Ubuntu 22.04. https://ros-qtc-plugin.readthedocs.io/en/latest/_source/How-to-Install-Users.html Once downloaded, the IDE can be installed using the command below (it is important to put cd in the download location): chmod +x qtcreator-ros-bionic-latest-offline-installer.run sudo ./qtcreator-ros-bionic-latest-offline-installer.run When the installer asks you where to install it, change it to e.g. /home/<USER>/QtCreator . If you put it in root, you will not be able to run it. After installation, look for `Qt Creator (4.9.2)'. CLion CLion has a high level of ROS integration, and its use is most recommended for this course. A free student license can be obtained at https://www.jetbrains.com/community/education/#students After installation, browse to the file /var/lib/snapd/desktop/applications/clion_clion.desktop . Copy the appropriate line here so that the IDE will use the environment set by the terminal: Exec = bash -i -c \"/snap/bin/clion\" %f Visual Studio Microsoft Visual Studio also supports source code for ROS, this IDE can also be used during the semester. Suggestion Install Terminator terminal emulator: sudo apt update sudo apt install terminator","title":"IDE"},{"location":"01_intro/#links","text":"https://www.ros.org/ ROS 2 Humble installation QtCreator + ROS plugin IROB virtual tour","title":"Links"},{"location":"02_linux_ros_principles/","text":"02. Linux, ROS introduction Lecture Linux principles (Was) the only OS supported by ROS Security Efficieny Open-source Community support User freedom Distributions: Ubuntu , Linux Mint, Debian, etc. Terminal usage more dominant Suggestion Install Terminator terminal emulator: sudo apt update sudo apt install terminator Linux commands See some basic commands below: Run as administrator with sudo Manual of command man , e.g. man cp Package management apt , e.g. apt update , apt install Navigation cd List directory contents ls Create file touch Copy file cp Move file mv Remove file rm Make directory mkdir Remove directory rmdir Make a file executable chmod +x <filename> Safe restart: Crtl + Alt + PrtScr + REISUB If not sure, just google the command ROS 1 \u2192 ROS 2 ROS 2 was rewritten from scratch More modular architecture Improved support for real-time systems Support for multiple communication protocols Better interoperability with other robotic systems Focus on standardization and industry collaboration No ROS Master No Devel space rclpy , rclcpp More structured code ( Node class) Different build system Platforms: Windows, OS X, Linux ROS principles ROS workspace Colcon workspace A folder where packages are modified, built, and installed. Source space: Source code of colcon packages Space where you can extract/checkout/clone source code for the packages you want to build Build space Colcon is invoked here to build packages Colcon and CMake keep intermediate files here Install space: Each package will be installed here; by default each package will be installed into a separate subdirectory Log space: Contains various logging information about each colcon invocation ROS package principle Enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software. ROS dependencies After cloning a new package, use the following command to install depenencies: rosdep install --from-paths src --ignore-src -r -y ROS package Main unit to organize software in ROS Buildable and redistributable unit of ROS code Consists of (in the case of Python packages): package.xml file containing meta information about the package name version description dependencies etc. setup.py containing instructions for how to install the package setup.cfg is required when a package has executables, so ros2 run can find them /<package_name> - a directory with the same name as your package, used by ROS 2 tools to find your package, contains __init__.py Anything else ros2 run turtlesim turtlesim_node CMake For CMake packages (C++), the package contents will be different. ROS node Executable part of ROS: python scripts compiled C++ code A process that performs computation Inter-node communication: ROS topics (streams) ROS parameter server Remote Procedure Calls (RPC) ROS services ROS actions Meant to operate at a fine-grained scale Typically, a robot control system consists of many nodes, like: Trajectory planning Localization Read sensory data Process sensory data Motor control User interface etc. ROS build system---Colcon System for building software packages in ROS Environmental setup file setup.bash generated during init process of a new workspace extends shell environment ROS can find any resources that have been installed or built to that location source ~/ros2_ws/install/setup.bash Practice 1: Turtlesim Start turtlesim_node and turtle_teleop_key nodes with the following commands, in separate terminal windows: ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Tip In Terminator , you can further divide the given window with Ctrl-Shift-O, Ctrl-Shift-E key combinations. Ctrl-Shift-W closes the active window. Abort execution Ctrl-C Running the following ROS commands can provide useful information: ros2 wtf ros2 node list ros2 node info /turtlesim ros2 topic list ros2 topic info /turtle1/cmd_vel ros2 interface show geometry_msgs/msg/Twist ros2 topic echo /turtle1/cmd_vel Start rqt_gui with the following command: ros2 run rqt_gui rqt_gui Display the running nodes and topics in rqt_gui : Plugins \u2192 Introspection \u2192 Node Graph. Publish to the /turtle1/cmd_vel topic also using rqt_gui : Plugins \u2192 Topics \u2192 Message Publisher. 2: ROS 2 workspace creation Let's create a new ROS2 workspace with the name ros2_ws . mkdir -p ~/ros2_ws/src 3: ROS 2 package creation Let's create a new ROS2 package with the name ros2_course and a Hello World. cd ~/ros2_ws/src ros2 pkg create --build-type ament_python --node-name hello ros2_course Syntax ros2 pkg create --build-type ament_python <package_name> Build the workspace. cd ~/ros2_ws colcon build --symlink-install Symlink The option --symlink-install links the source scripts to the Install space, so we don't have to build again after modification. Insert the following line at the end of the ~/.bashrc file: source ~/ros2_ws/install/setup.bash Import to QtCreator New file or project \u2192 Other project \u2192 ROS Workspace. Select Colcon as Build System and ros2_ws as Workspace path. Import to CLion Set the Python interpreter to Python 3.8, /usr/bin/python3 . Add the follwong path: /opt/ros/foxy/lib/python3.8/site-packages . Hozzuk l\u00e9tre a compile_commands.json f\u00e1jlt a ~/ros2_ws/build k\u00f6nyvt\u00e1rban az al\u00e1bbi tartalommal: [ ] Test Hello World: ros2 run ros2_course hello 4: Implementing a Publisher in Python Navigate to the ros2_ws/src/ros2_course/ros2_course folder and create the talker.py file with the content below. import rclpy from rclpy.node import Node from std_msgs.msg import String class MinimalPublisher ( Node ): def __init__ ( self ): super () . __init__ ( 'minimal_publisher' ) self . publisher_ = self . create_publisher ( String , 'chatter' , 10 ) timer_period = 0.5 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 def timer_callback ( self ): msg = String () msg . data = 'Hello World: %d ' % self . i self . publisher_ . publish ( msg ) self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) self . i += 1 def main ( args = None ): rclpy . init ( args = args ) minimal_publisher = MinimalPublisher () rclpy . spin ( minimal_publisher ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Add a new entry point in the setup.py file: 'talker = ros2_course.talker:main' , Build and run the node: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course talker Check the output of the node using ros2 topic echo command or rqt_gui . 5: Implementing a Subscriber in Python Navigate to the ros2_ws/src/ros2_course/ros2_course folder and create the listener.py file with the content below. import rclpy from rclpy.node import Node from std_msgs.msg import String class MinimalSubscriber ( Node ): def __init__ ( self ): super () . __init__ ( 'minimal_subscriber' ) self . subscription = self . create_subscription ( String , 'chatter' , self . listener_callback , 10 ) self . subscription # prevent unused variable warning def listener_callback ( self , msg ): self . get_logger () . info ( 'I heard msg: \" %s \"' % msg . data ) def main ( args = None ): rclpy . init ( args = args ) minimal_subscriber = MinimalSubscriber () rclpy . spin ( minimal_subscriber ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Add a new entry point in the setup.py file: 'listener = ros2_course.listener:main' , Build and run both nodes: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course talker ros2 run ros2_course listener Use rqt_gui to display the nodes and topics of the running system: ros2 run rqt_gui rqt_gui Useful links ROS 2 Tutorials What is a ROS 2 package?","title":"2. Linux and ROS principles"},{"location":"02_linux_ros_principles/#02-linux-ros-introduction","text":"","title":"02. Linux, ROS introduction"},{"location":"02_linux_ros_principles/#lecture","text":"","title":"Lecture"},{"location":"02_linux_ros_principles/#linux-principles","text":"(Was) the only OS supported by ROS Security Efficieny Open-source Community support User freedom Distributions: Ubuntu , Linux Mint, Debian, etc. Terminal usage more dominant Suggestion Install Terminator terminal emulator: sudo apt update sudo apt install terminator","title":"Linux principles"},{"location":"02_linux_ros_principles/#linux-commands","text":"See some basic commands below: Run as administrator with sudo Manual of command man , e.g. man cp Package management apt , e.g. apt update , apt install Navigation cd List directory contents ls Create file touch Copy file cp Move file mv Remove file rm Make directory mkdir Remove directory rmdir Make a file executable chmod +x <filename> Safe restart: Crtl + Alt + PrtScr + REISUB If not sure, just google the command","title":"Linux commands"},{"location":"02_linux_ros_principles/#ros-1-ros-2","text":"ROS 2 was rewritten from scratch More modular architecture Improved support for real-time systems Support for multiple communication protocols Better interoperability with other robotic systems Focus on standardization and industry collaboration No ROS Master No Devel space rclpy , rclcpp More structured code ( Node class) Different build system Platforms: Windows, OS X, Linux","title":"ROS 1 &rarr; ROS 2"},{"location":"02_linux_ros_principles/#ros-principles","text":"","title":"ROS principles"},{"location":"02_linux_ros_principles/#ros-workspace","text":"Colcon workspace A folder where packages are modified, built, and installed. Source space: Source code of colcon packages Space where you can extract/checkout/clone source code for the packages you want to build Build space Colcon is invoked here to build packages Colcon and CMake keep intermediate files here Install space: Each package will be installed here; by default each package will be installed into a separate subdirectory Log space: Contains various logging information about each colcon invocation ROS package principle Enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software. ROS dependencies After cloning a new package, use the following command to install depenencies: rosdep install --from-paths src --ignore-src -r -y","title":"ROS workspace"},{"location":"02_linux_ros_principles/#ros-package","text":"Main unit to organize software in ROS Buildable and redistributable unit of ROS code Consists of (in the case of Python packages): package.xml file containing meta information about the package name version description dependencies etc. setup.py containing instructions for how to install the package setup.cfg is required when a package has executables, so ros2 run can find them /<package_name> - a directory with the same name as your package, used by ROS 2 tools to find your package, contains __init__.py Anything else ros2 run turtlesim turtlesim_node CMake For CMake packages (C++), the package contents will be different.","title":"ROS package"},{"location":"02_linux_ros_principles/#ros-node","text":"Executable part of ROS: python scripts compiled C++ code A process that performs computation Inter-node communication: ROS topics (streams) ROS parameter server Remote Procedure Calls (RPC) ROS services ROS actions Meant to operate at a fine-grained scale Typically, a robot control system consists of many nodes, like: Trajectory planning Localization Read sensory data Process sensory data Motor control User interface etc.","title":"ROS node"},{"location":"02_linux_ros_principles/#ros-build-system-colcon","text":"System for building software packages in ROS","title":"ROS build system---Colcon"},{"location":"02_linux_ros_principles/#environmental-setup-file","text":"setup.bash generated during init process of a new workspace extends shell environment ROS can find any resources that have been installed or built to that location source ~/ros2_ws/install/setup.bash","title":"Environmental setup file"},{"location":"02_linux_ros_principles/#practice","text":"","title":"Practice"},{"location":"02_linux_ros_principles/#1-turtlesim","text":"Start turtlesim_node and turtle_teleop_key nodes with the following commands, in separate terminal windows: ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key Tip In Terminator , you can further divide the given window with Ctrl-Shift-O, Ctrl-Shift-E key combinations. Ctrl-Shift-W closes the active window. Abort execution Ctrl-C Running the following ROS commands can provide useful information: ros2 wtf ros2 node list ros2 node info /turtlesim ros2 topic list ros2 topic info /turtle1/cmd_vel ros2 interface show geometry_msgs/msg/Twist ros2 topic echo /turtle1/cmd_vel Start rqt_gui with the following command: ros2 run rqt_gui rqt_gui Display the running nodes and topics in rqt_gui : Plugins \u2192 Introspection \u2192 Node Graph. Publish to the /turtle1/cmd_vel topic also using rqt_gui : Plugins \u2192 Topics \u2192 Message Publisher.","title":"1: Turtlesim"},{"location":"02_linux_ros_principles/#2-ros-2-workspace-creation","text":"Let's create a new ROS2 workspace with the name ros2_ws . mkdir -p ~/ros2_ws/src","title":"2: ROS 2 workspace creation"},{"location":"02_linux_ros_principles/#3-ros-2-package-creation","text":"Let's create a new ROS2 package with the name ros2_course and a Hello World. cd ~/ros2_ws/src ros2 pkg create --build-type ament_python --node-name hello ros2_course Syntax ros2 pkg create --build-type ament_python <package_name> Build the workspace. cd ~/ros2_ws colcon build --symlink-install Symlink The option --symlink-install links the source scripts to the Install space, so we don't have to build again after modification. Insert the following line at the end of the ~/.bashrc file: source ~/ros2_ws/install/setup.bash Import to QtCreator New file or project \u2192 Other project \u2192 ROS Workspace. Select Colcon as Build System and ros2_ws as Workspace path. Import to CLion Set the Python interpreter to Python 3.8, /usr/bin/python3 . Add the follwong path: /opt/ros/foxy/lib/python3.8/site-packages . Hozzuk l\u00e9tre a compile_commands.json f\u00e1jlt a ~/ros2_ws/build k\u00f6nyvt\u00e1rban az al\u00e1bbi tartalommal: [ ] Test Hello World: ros2 run ros2_course hello","title":"3: ROS 2 package creation"},{"location":"02_linux_ros_principles/#4-implementing-a-publisher-in-python","text":"Navigate to the ros2_ws/src/ros2_course/ros2_course folder and create the talker.py file with the content below. import rclpy from rclpy.node import Node from std_msgs.msg import String class MinimalPublisher ( Node ): def __init__ ( self ): super () . __init__ ( 'minimal_publisher' ) self . publisher_ = self . create_publisher ( String , 'chatter' , 10 ) timer_period = 0.5 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 def timer_callback ( self ): msg = String () msg . data = 'Hello World: %d ' % self . i self . publisher_ . publish ( msg ) self . get_logger () . info ( 'Publishing: \" %s \"' % msg . data ) self . i += 1 def main ( args = None ): rclpy . init ( args = args ) minimal_publisher = MinimalPublisher () rclpy . spin ( minimal_publisher ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Add a new entry point in the setup.py file: 'talker = ros2_course.talker:main' , Build and run the node: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course talker Check the output of the node using ros2 topic echo command or rqt_gui .","title":"4: Implementing a Publisher in Python"},{"location":"02_linux_ros_principles/#5-implementing-a-subscriber-in-python","text":"Navigate to the ros2_ws/src/ros2_course/ros2_course folder and create the listener.py file with the content below. import rclpy from rclpy.node import Node from std_msgs.msg import String class MinimalSubscriber ( Node ): def __init__ ( self ): super () . __init__ ( 'minimal_subscriber' ) self . subscription = self . create_subscription ( String , 'chatter' , self . listener_callback , 10 ) self . subscription # prevent unused variable warning def listener_callback ( self , msg ): self . get_logger () . info ( 'I heard msg: \" %s \"' % msg . data ) def main ( args = None ): rclpy . init ( args = args ) minimal_subscriber = MinimalSubscriber () rclpy . spin ( minimal_subscriber ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) minimal_subscriber . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Add a new entry point in the setup.py file: 'listener = ros2_course.listener:main' , Build and run both nodes: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course talker ros2 run ros2_course listener Use rqt_gui to display the nodes and topics of the running system: ros2 run rqt_gui rqt_gui","title":"5: Implementing a Subscriber in Python"},{"location":"02_linux_ros_principles/#useful-links","text":"ROS 2 Tutorials What is a ROS 2 package?","title":"Useful links"},{"location":"03_python_principles/","text":"03. Python principles, ROS Publisher, ROS Subscriber Lecture Python principles Interpreted, high-level programming language Name tribute to the comedy group Monty Python Powerful, still easy to learn, easy to use Readability Whitespace indentation Dynamically-typed Garbage colector and reference counting Object oriented programming Used in: AI, web applications, scientific computing, and many other areas python3 Python syntax import numpy as np import math class A : def __init__ ( self , name ): self . name = name def do_something ( self ): # will do something print ( self . name + \" is doing something.\" ) def count_to ( self , n ): # count to n, tell if the number is odd or even for i in range ( n ): if i % 2 == 0 : print ( i + \", it's even.\" ) else : print ( i + \", it's odd.\" ) if __name__ == \"__main__\" : a = A ( \"John\" ) a . do_something () a . count_to ( 10 ) Practice 1: Move the turtle in a straight line Let's write a ROS node that moves the turtle forward along a straight line for a given distance. Let's open a terminal. Let's create ~/ros2_ws/src/ros2_course/ros2_course the turtlesim_controller.py file in our directory: ```bash cd ros2_ws/src/ros2_course/ros2_course touch turtlesim_controller.py ``` --- Add a new entry point in the setup.py file: 'turtlesim_controller = ros2_course.turtlesim_controller:main' , Copy the skeleton of the program into turtlesim_controller.py : import math import rclpy from rclpy.node import Node class TurtlesimController ( Node ): def __init__ ( self ): super () . __init__ ( 'turtlesim_controller' ) def go_straight ( self , speed , distance ): # Implement straght motion here def main ( args = None ): rclpy . init ( args = args ) tc = TurtlesimController () # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) tc . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Let's start a turtlesim_node and then examine the topic, with which we can control. In two separate terminal windows: ros2 run turtlesim turtlesim_node ros2 topic list ros2 topic info /turtle1/cmd_vel ros2 interface show geometry_msgs/msg/Twist Or use rqt_gui : ros2 run rqt_gui rqt_gui Import the message type geometry_msgs/msg/Twist and create the publisher in turtlesim_controller.py : from geometry_msgs.msg import Twist #... # In the constructor: self . twist_pub = self . create_publisher ( Twist , '/turtle1/cmd_vel' , 10 ) We implement the go_straight method. Let's calculate how long it takes, so that the turtle covers the given distance at the given speed. Publish a message with which we set the speed, then wait for the calculated time, after that send another message to reset the speed. A little help for using the API: # Create and publish msg vel_msg = Twist () if distance > 0 : vel_msg . linear . x = speed else : vel_msg . linear . x = - speed vel_msg . linear . y = 0.0 vel_msg . linear . z = 0.0 vel_msg . angular . x = 0.0 vel_msg . angular . y = 0.0 vel_msg . angular . z = 0.0 # Set loop rate loop_rate = self . create_rate ( 100 , self . get_clock ()) # Hz # Calculate time # T = ... # Publish first msg and note time when to stop self . twist_pub . publish ( vel_msg ) # self.get_logger().info('Turtle started.') when = self . get_clock () . now () + rclpy . time . Duration ( seconds = T ) # Publish msg while the calculated time is up while ( some condition ... ) and rclpy . ok (): self . twist_pub . publish ( vel_msg ) # self.get_logger().info('On its way...') rclpy . spin_once ( self ) # loop rate # turtle arrived, set velocity to 0 vel_msg . linear . x = 0.0 self . twist_pub . publish ( vel_msg ) # self.get_logger().info('Arrived to destination.') Build and run the node: cd ros2_ws colcon build --symlink-install ros2 run ros2_course turtlesim_controller 2: Draw shapes Let's implement the method for turning with a given angle a in turtlesim_controller.py , similar to straight motion. def turn ( self , omega , angle ): # Implement rotation here Let's implement the straight movement method of drawing a square with a turtle and using the methods that perform the turn. def draw_square ( self , speed , omega , a ): Let's implement the method of drawing any regular shape with a turtle using the methods that perform straight movement and turning. def draw_poly ( self , speed , omega , N , a ): 3: Go to function Let's examine the topic on which turtlesim_node publishes its current position. ros2 topic list ros2 topic info /turtle1/pose ros2 interface show turtlesim/msg/Pose Or use rqt_gui : ros2 run rqt_gui rqt_gui Let's define a subscriber for the topic and write the callback function. # Imports from turtlesim.msg import Pose # Constructor self . pose = None self . subscription = self . create_subscription ( Pose , '/turtle1/pose' , self . cb_pose , 10 ) # New method for TurtlesimController def cb_pose ( self , msg ): self . pose = msg We implement the go_to method. Let's test it, call it from main. # ... # Go to method def go_to ( self , speed , omega , x , y ): # Wait for position to be received loop_rate = self . create_rate ( 100 , self . get_clock ()) # Hz while self . pose is None and rclpy . ok (): self . get_logger () . info ( 'Waiting for pose...' ) rclpy . spin_once ( self ) # Stuff with atan2 # Main def main ( args = None ): rclpy . init ( args = args ) tc = TurtlesimController () tc . go_to ( 1.0 , 20.0 , 2 , 8 ) tc . go_to ( 1.0 , 20.0 , 2 , 2 ) tc . go_to ( 1.0 , 20.0 , 3 , 4 ) tc . go_to ( 1.0 , 20.0 , 6 , 2 ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) tc . destroy_node () rclpy . shutdown () Extra: Advanced go to Write a go to function that uses a proportional controller. Useful links For loops in python Some python functions Turtlesim help atan2","title":"3. Python principles, ROS Publisher, ROS Subscriber"},{"location":"03_python_principles/#03-python-principles-ros-publisher-ros-subscriber","text":"","title":"03. Python principles, ROS Publisher, ROS Subscriber"},{"location":"03_python_principles/#lecture","text":"","title":"Lecture"},{"location":"03_python_principles/#python-principles","text":"Interpreted, high-level programming language Name tribute to the comedy group Monty Python Powerful, still easy to learn, easy to use Readability Whitespace indentation Dynamically-typed Garbage colector and reference counting Object oriented programming Used in: AI, web applications, scientific computing, and many other areas python3","title":"Python principles"},{"location":"03_python_principles/#python-syntax","text":"import numpy as np import math class A : def __init__ ( self , name ): self . name = name def do_something ( self ): # will do something print ( self . name + \" is doing something.\" ) def count_to ( self , n ): # count to n, tell if the number is odd or even for i in range ( n ): if i % 2 == 0 : print ( i + \", it's even.\" ) else : print ( i + \", it's odd.\" ) if __name__ == \"__main__\" : a = A ( \"John\" ) a . do_something () a . count_to ( 10 )","title":"Python syntax"},{"location":"03_python_principles/#practice","text":"","title":"Practice"},{"location":"03_python_principles/#1-move-the-turtle-in-a-straight-line","text":"Let's write a ROS node that moves the turtle forward along a straight line for a given distance. Let's open a terminal. Let's create ~/ros2_ws/src/ros2_course/ros2_course the turtlesim_controller.py file in our directory: ```bash cd ros2_ws/src/ros2_course/ros2_course touch turtlesim_controller.py ``` --- Add a new entry point in the setup.py file: 'turtlesim_controller = ros2_course.turtlesim_controller:main' , Copy the skeleton of the program into turtlesim_controller.py : import math import rclpy from rclpy.node import Node class TurtlesimController ( Node ): def __init__ ( self ): super () . __init__ ( 'turtlesim_controller' ) def go_straight ( self , speed , distance ): # Implement straght motion here def main ( args = None ): rclpy . init ( args = args ) tc = TurtlesimController () # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) tc . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Let's start a turtlesim_node and then examine the topic, with which we can control. In two separate terminal windows: ros2 run turtlesim turtlesim_node ros2 topic list ros2 topic info /turtle1/cmd_vel ros2 interface show geometry_msgs/msg/Twist Or use rqt_gui : ros2 run rqt_gui rqt_gui Import the message type geometry_msgs/msg/Twist and create the publisher in turtlesim_controller.py : from geometry_msgs.msg import Twist #... # In the constructor: self . twist_pub = self . create_publisher ( Twist , '/turtle1/cmd_vel' , 10 ) We implement the go_straight method. Let's calculate how long it takes, so that the turtle covers the given distance at the given speed. Publish a message with which we set the speed, then wait for the calculated time, after that send another message to reset the speed. A little help for using the API: # Create and publish msg vel_msg = Twist () if distance > 0 : vel_msg . linear . x = speed else : vel_msg . linear . x = - speed vel_msg . linear . y = 0.0 vel_msg . linear . z = 0.0 vel_msg . angular . x = 0.0 vel_msg . angular . y = 0.0 vel_msg . angular . z = 0.0 # Set loop rate loop_rate = self . create_rate ( 100 , self . get_clock ()) # Hz # Calculate time # T = ... # Publish first msg and note time when to stop self . twist_pub . publish ( vel_msg ) # self.get_logger().info('Turtle started.') when = self . get_clock () . now () + rclpy . time . Duration ( seconds = T ) # Publish msg while the calculated time is up while ( some condition ... ) and rclpy . ok (): self . twist_pub . publish ( vel_msg ) # self.get_logger().info('On its way...') rclpy . spin_once ( self ) # loop rate # turtle arrived, set velocity to 0 vel_msg . linear . x = 0.0 self . twist_pub . publish ( vel_msg ) # self.get_logger().info('Arrived to destination.') Build and run the node: cd ros2_ws colcon build --symlink-install ros2 run ros2_course turtlesim_controller","title":"1: Move the turtle in a straight line"},{"location":"03_python_principles/#2-draw-shapes","text":"Let's implement the method for turning with a given angle a in turtlesim_controller.py , similar to straight motion. def turn ( self , omega , angle ): # Implement rotation here Let's implement the straight movement method of drawing a square with a turtle and using the methods that perform the turn. def draw_square ( self , speed , omega , a ): Let's implement the method of drawing any regular shape with a turtle using the methods that perform straight movement and turning. def draw_poly ( self , speed , omega , N , a ):","title":"2: Draw shapes"},{"location":"03_python_principles/#3-go-to-function","text":"Let's examine the topic on which turtlesim_node publishes its current position. ros2 topic list ros2 topic info /turtle1/pose ros2 interface show turtlesim/msg/Pose Or use rqt_gui : ros2 run rqt_gui rqt_gui Let's define a subscriber for the topic and write the callback function. # Imports from turtlesim.msg import Pose # Constructor self . pose = None self . subscription = self . create_subscription ( Pose , '/turtle1/pose' , self . cb_pose , 10 ) # New method for TurtlesimController def cb_pose ( self , msg ): self . pose = msg We implement the go_to method. Let's test it, call it from main. # ... # Go to method def go_to ( self , speed , omega , x , y ): # Wait for position to be received loop_rate = self . create_rate ( 100 , self . get_clock ()) # Hz while self . pose is None and rclpy . ok (): self . get_logger () . info ( 'Waiting for pose...' ) rclpy . spin_once ( self ) # Stuff with atan2 # Main def main ( args = None ): rclpy . init ( args = args ) tc = TurtlesimController () tc . go_to ( 1.0 , 20.0 , 2 , 8 ) tc . go_to ( 1.0 , 20.0 , 2 , 2 ) tc . go_to ( 1.0 , 20.0 , 3 , 4 ) tc . go_to ( 1.0 , 20.0 , 6 , 2 ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) tc . destroy_node () rclpy . shutdown ()","title":"3: Go to function"},{"location":"03_python_principles/#extra-advanced-go-to","text":"Write a go to function that uses a proportional controller.","title":"Extra: Advanced go to"},{"location":"03_python_principles/#useful-links","text":"For loops in python Some python functions Turtlesim help atan2","title":"Useful links"},{"location":"04_da_vinci/","text":"04. Principles of robotics. Programming a da Vinci surgical robot in simulated environment. Lecture Warning Test 1 (ROS principles, publisher, subscriber. Python principles. Principles of robotics.) October 27. Rigid body motion Def. Rigid body A rigid body is defined as a body on which the distance between two points remains constant in time regardless of the force applied on it. Shape and the volume of the rigid bodies are also constant. The pose of a rigid body can be given by the three coordinates of three of its points that do not lie on the same straight line. The pose of a rigid body can be described in a more expressive way by the three coordinates of one of its points chosen arbitrarily position and the body's orientation . The motion of rigid bodies is composed by two elemental motions: translation and rotation . During translation , all points of the body move along straight, parallel lines. During rotation , the position of the points of the rotational axis are constant, and the other points of the body move along circles in planes perpendicular to the axis of rotation. The free motion of rigid bodies can always be expressed as the superposition of a translational motion and a rotation around a single axis. 3D transformations Position: 3D offset vector Orientation: 3 x 3 rotation matrix further orientation representations: Euler-angles, RPY, angle axis, quaternion Pose : 4 \u00d7 4 (homogenous) transformation matrix Frame : origin, 3 axes, 3 base vectors, right hand rule Homogenous transformation: rotation and translation in one transfromation e.g., for the rotation \\(\\mathbf{R}\\) and translation \\(\\mathbf{v}\\) : \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right] = \\left[\\matrix{r_{1,1} & r_{1,2} & r_{1,3} & v_x\\\\r_{2,1} & r_{2,2} & r_{2,3} & v_y\\\\r_{3,1} & r_{3,2} & r_{3,3} & v_z\\\\\\ 0 & 0 & 0 & 1 }\\right] \\] Homogenous coordinates: Vector: extended with 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\) Point: extended by 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\) Applying transfomrations is much easier: \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] Degrees of Freedom (DoF): the number of independent parameters. Principles of robotics Robots are built of: segments (or links) \u00e9s joints Task space (or cartesian space): 3D space around us, where the task, endpoint trajectories, obstacles are defined. TCP (Tool Center Point): Frame fixed to the end effector of the robot. Base frame , world frame Joint space : Properties or values regarding the joints. Low-level controller. Joint angles, joint velocities, accelerations, torques.... Python libraries Numpy Python library High dimension arrays and matrices Mathematical functions import numpy as np # Creating ndarrays a = np . zeros ( 3 ) a . shape a . shape = ( 3 , 1 ) a = np . ones ( 5 ) a = np . empty ( 10 ) l = np . linspace ( 5 , 10 , 6 ) r = np . array ([ 1 , 2 ]) # ndarray from python list r = np . array ([[ 1 , 2 ],[ 3 , 4 ]]) type ( r ) # Indexing l [ 0 ] l [ 0 : 2 ] l [ - 1 ] r [:, 0 ] # Operations on ndarrays r_sin = np . sin ( r ) np . max ( r ) np . min ( r ) np . sum ( r ) np . mean ( r ) np . std ( r ) l < 7 l [ l < 7 ] np . where ( l < 7 ) p = np . linspace ( 1 , 5 , 6 ) q = np . linspace ( 10 , 14 , 6 ) s = p + q s = p * q s = p * 10 s = p + 10 s = p @ q # dot product s = r . T If not installed: pip3 install numpy Matplotlib Visualization in python Syntax similar to Matlab import numpy as np from matplotlib import pyplot as plt X = np . linspace ( - np . pi , np . pi , 256 ) C , S = np . cos ( X ), np . sin ( X ) plt . plot ( X , C ) plt . plot ( X , S ) plt . show () If not installed: pip3 install matplotlib Practice 1. dVRK ROS 2 install The da Vinci Surgical System is used to perform minimally invasive surgeries by teleoperation. The da Vinci Research Kit (DVRK) is an open-source hardware and software platform, offers, amongst others, reading and writing all the joints of the da Vinci, and also simulators for each arm. The DVRK software can be built as follows. Clone the dVRK (da Vinci Reserach Kit) using vcs into a new workspace, then build it: mkdir -p ~/dvrk2_ws/src cd ~/dvrk2_ws/src vcs import --input https://raw.githubusercontent.com/jhu-dvrk/dvrk_robot_ros2/devel/dvrk-2.2.vcs --recursive cd ~/dvrk2_ws cd ~/dvrk2_ws colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release source ~/dvrk2_ws/install/setup.bash Add the following line to the end of the .bashrc file: source ~/dvrk2_ws/install/setup.bash Run these commands in separate terminals to launch the simulation. Do not forget to push the Home button in the DVRK console. # dVRK main console ros2 run dvrk_robot dvrk_console_json -j ~/dvrk2_ws/install/sawIntuitiveResearchKitAll/share/sawIntuitiveResearchKit/share/console/console-PSM1_KIN_SIMULATED.json # ROS 2 joint and robot state publishers ros2 launch dvrk_model dvrk_state_publisher.launch.py arm: = PSM1 # RViz ros2 run rviz2 rviz2 -d ~/dvrk2_ws/install/dvrk_model/share/dvrk_model/rviz/PSM1.rviz # rqt_gui ros2 run rqt_gui rqt_gui 2. PSM subscriber Create a new file named psm_grasp.py in the ~/ros2_ws/src/ros2_course/ros2_course folder. Add the new entry point to the setup.py , as usually. Check the topics and nodes of the simulator using the commands learned earlier ( rostopic list , rosrun rqt_graph rqt_graph , etc.). PSM1 publishes the pose of the TCP and the angle of the jaws into the topics below. Subscribe to these topic in psm_grasp.py and store the current values into variables. /PSM1/measured_cp /PSM1/jaw/measured_js Build and run the node: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course psm_grasp 3. Move the TCP along a linear trajectory PSM1 expects commands regarding the pose of the TCP and the angle of the jaws from the topics below. Create publishers to these topic in psm_grasp.py . /PSM1/servo_cp /PSM1/jaw/servo_jp Implement a method that moves the TCP to the desired position along a linear trajectory. Send the gripper to the position (0.0, 0.05, -0.12), leave the orientation as it is. Let the sampling time dt be 0.01s. def move_tcp_to ( self , target , v , dt ): Tip Use the function np.linspace(start, stop, num) to create the array of t values (T). This function can also be used to create the linear trajectory along the axes x, y, z in separate arrays X, Y and Z. Write a method that can open and close the gripper jaws, also along a linear trajectory. def move_jaw_to ( self , target , omega , dt ): 4. Dummy marker Write a node that creates a virtual marker that can be grasped publishing visualization_msgs/Marker messages. Create a new file named dummy_marker.py in the ~/ros2_ws/src/ros2_course/ros2_course folder. Add it to the setup.py , as usually. Copy the following code into the file dummy_marker.py : import rclpy from rclpy.node import Node from visualization_msgs.msg import Marker class DummyMarker ( Node ): def __init__ ( self , position ): super () . __init__ ( 'minimal_publisher' ) self . position = position self . publisher_ = self . create_publisher ( Marker , 'dummy_target_marker' , 10 ) timer_period = 0.1 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 i = 0 def timer_callback ( self ): marker = Marker () marker . header . frame_id = 'PSM1_psm_base_link' marker . header . stamp = self . get_clock () . now () . to_msg () marker . ns = \"dvrk_viz\" marker . id = self . i marker . type = Marker . SPHERE marker . action = Marker . MODIFY marker . pose . position . x = self . position [ 0 ] marker . pose . position . y = self . position [ 1 ] marker . pose . position . z = self . position [ 2 ] marker . pose . orientation . x = 0.0 marker . pose . orientation . y = 0.0 marker . pose . orientation . z = 0.0 marker . pose . orientation . w = 1.0 marker . scale . x = 0.008 marker . scale . y = 0.008 marker . scale . z = 0.008 marker . color . a = 1.0 # Don't forget to set the alpha! marker . color . r = 0.0 marker . color . g = 1.0 marker . color . b = 0.0 ; self . publisher_ . publish ( marker ) self . i += 1 def main ( args = None ): rclpy . init ( args = args ) marker_publisher = DummyMarker ([ - 0.05 , 0.08 , - 0.12 ]) rclpy . spin ( marker_publisher ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) marker_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Build and run the node. Visualize the marker in RViz. 5. Grasp the marker Subscribe to the topic with the marker position dummy_target_publisher the file psm_grasp.py . Implement a method in psm_grasp.py to grasp the generated marker with PSM1. Note Some values tends to stuck in the simulator. Thus, at the beginning of the program, it is a good idea to reset the arm: #Reset the arm psm . move_tcp_to ([ 0.0 , 0.0 , - 0.12 ], 0.01 , 0.01 ) psm . move_jaw_to ( 0.0 , 0.1 , 0.01 ) Links Download and compile dVRK 2 Marker examples Numpy vector magnitude Numpy linspace","title":"4. Principles of robotics, da Vinci"},{"location":"04_da_vinci/#04-principles-of-robotics-programming-a-da-vinci-surgical-robot-in-simulated-environment","text":"","title":"04. Principles of robotics. Programming a da Vinci surgical robot in simulated environment."},{"location":"04_da_vinci/#lecture","text":"Warning Test 1 (ROS principles, publisher, subscriber. Python principles. Principles of robotics.) October 27.","title":"Lecture"},{"location":"04_da_vinci/#rigid-body-motion","text":"Def. Rigid body A rigid body is defined as a body on which the distance between two points remains constant in time regardless of the force applied on it. Shape and the volume of the rigid bodies are also constant. The pose of a rigid body can be given by the three coordinates of three of its points that do not lie on the same straight line. The pose of a rigid body can be described in a more expressive way by the three coordinates of one of its points chosen arbitrarily position and the body's orientation . The motion of rigid bodies is composed by two elemental motions: translation and rotation . During translation , all points of the body move along straight, parallel lines. During rotation , the position of the points of the rotational axis are constant, and the other points of the body move along circles in planes perpendicular to the axis of rotation. The free motion of rigid bodies can always be expressed as the superposition of a translational motion and a rotation around a single axis.","title":"Rigid body motion"},{"location":"04_da_vinci/#3d-transformations","text":"Position: 3D offset vector Orientation: 3 x 3 rotation matrix further orientation representations: Euler-angles, RPY, angle axis, quaternion Pose : 4 \u00d7 4 (homogenous) transformation matrix Frame : origin, 3 axes, 3 base vectors, right hand rule Homogenous transformation: rotation and translation in one transfromation e.g., for the rotation \\(\\mathbf{R}\\) and translation \\(\\mathbf{v}\\) : \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right] = \\left[\\matrix{r_{1,1} & r_{1,2} & r_{1,3} & v_x\\\\r_{2,1} & r_{2,2} & r_{2,3} & v_y\\\\r_{3,1} & r_{3,2} & r_{3,3} & v_z\\\\\\ 0 & 0 & 0 & 1 }\\right] \\] Homogenous coordinates: Vector: extended with 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\) Point: extended by 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\) Applying transfomrations is much easier: \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] Degrees of Freedom (DoF): the number of independent parameters.","title":"3D transformations"},{"location":"04_da_vinci/#principles-of-robotics","text":"Robots are built of: segments (or links) \u00e9s joints Task space (or cartesian space): 3D space around us, where the task, endpoint trajectories, obstacles are defined. TCP (Tool Center Point): Frame fixed to the end effector of the robot. Base frame , world frame Joint space : Properties or values regarding the joints. Low-level controller. Joint angles, joint velocities, accelerations, torques....","title":"Principles of robotics"},{"location":"04_da_vinci/#python-libraries","text":"","title":"Python libraries"},{"location":"04_da_vinci/#numpy","text":"Python library High dimension arrays and matrices Mathematical functions import numpy as np # Creating ndarrays a = np . zeros ( 3 ) a . shape a . shape = ( 3 , 1 ) a = np . ones ( 5 ) a = np . empty ( 10 ) l = np . linspace ( 5 , 10 , 6 ) r = np . array ([ 1 , 2 ]) # ndarray from python list r = np . array ([[ 1 , 2 ],[ 3 , 4 ]]) type ( r ) # Indexing l [ 0 ] l [ 0 : 2 ] l [ - 1 ] r [:, 0 ] # Operations on ndarrays r_sin = np . sin ( r ) np . max ( r ) np . min ( r ) np . sum ( r ) np . mean ( r ) np . std ( r ) l < 7 l [ l < 7 ] np . where ( l < 7 ) p = np . linspace ( 1 , 5 , 6 ) q = np . linspace ( 10 , 14 , 6 ) s = p + q s = p * q s = p * 10 s = p + 10 s = p @ q # dot product s = r . T If not installed: pip3 install numpy","title":"Numpy"},{"location":"04_da_vinci/#matplotlib","text":"Visualization in python Syntax similar to Matlab import numpy as np from matplotlib import pyplot as plt X = np . linspace ( - np . pi , np . pi , 256 ) C , S = np . cos ( X ), np . sin ( X ) plt . plot ( X , C ) plt . plot ( X , S ) plt . show () If not installed: pip3 install matplotlib","title":"Matplotlib"},{"location":"04_da_vinci/#practice","text":"","title":"Practice"},{"location":"04_da_vinci/#1-dvrk-ros-2-install","text":"The da Vinci Surgical System is used to perform minimally invasive surgeries by teleoperation. The da Vinci Research Kit (DVRK) is an open-source hardware and software platform, offers, amongst others, reading and writing all the joints of the da Vinci, and also simulators for each arm. The DVRK software can be built as follows. Clone the dVRK (da Vinci Reserach Kit) using vcs into a new workspace, then build it: mkdir -p ~/dvrk2_ws/src cd ~/dvrk2_ws/src vcs import --input https://raw.githubusercontent.com/jhu-dvrk/dvrk_robot_ros2/devel/dvrk-2.2.vcs --recursive cd ~/dvrk2_ws cd ~/dvrk2_ws colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE = Release source ~/dvrk2_ws/install/setup.bash Add the following line to the end of the .bashrc file: source ~/dvrk2_ws/install/setup.bash Run these commands in separate terminals to launch the simulation. Do not forget to push the Home button in the DVRK console. # dVRK main console ros2 run dvrk_robot dvrk_console_json -j ~/dvrk2_ws/install/sawIntuitiveResearchKitAll/share/sawIntuitiveResearchKit/share/console/console-PSM1_KIN_SIMULATED.json # ROS 2 joint and robot state publishers ros2 launch dvrk_model dvrk_state_publisher.launch.py arm: = PSM1 # RViz ros2 run rviz2 rviz2 -d ~/dvrk2_ws/install/dvrk_model/share/dvrk_model/rviz/PSM1.rviz # rqt_gui ros2 run rqt_gui rqt_gui","title":"1. dVRK ROS 2 install"},{"location":"04_da_vinci/#2-psm-subscriber","text":"Create a new file named psm_grasp.py in the ~/ros2_ws/src/ros2_course/ros2_course folder. Add the new entry point to the setup.py , as usually. Check the topics and nodes of the simulator using the commands learned earlier ( rostopic list , rosrun rqt_graph rqt_graph , etc.). PSM1 publishes the pose of the TCP and the angle of the jaws into the topics below. Subscribe to these topic in psm_grasp.py and store the current values into variables. /PSM1/measured_cp /PSM1/jaw/measured_js Build and run the node: cd ~/ros2_ws colcon build --symlink-install ros2 run ros2_course psm_grasp","title":"2. PSM subscriber"},{"location":"04_da_vinci/#3-move-the-tcp-along-a-linear-trajectory","text":"PSM1 expects commands regarding the pose of the TCP and the angle of the jaws from the topics below. Create publishers to these topic in psm_grasp.py . /PSM1/servo_cp /PSM1/jaw/servo_jp Implement a method that moves the TCP to the desired position along a linear trajectory. Send the gripper to the position (0.0, 0.05, -0.12), leave the orientation as it is. Let the sampling time dt be 0.01s. def move_tcp_to ( self , target , v , dt ): Tip Use the function np.linspace(start, stop, num) to create the array of t values (T). This function can also be used to create the linear trajectory along the axes x, y, z in separate arrays X, Y and Z. Write a method that can open and close the gripper jaws, also along a linear trajectory. def move_jaw_to ( self , target , omega , dt ):","title":"3. Move the TCP along a linear trajectory"},{"location":"04_da_vinci/#4-dummy-marker","text":"Write a node that creates a virtual marker that can be grasped publishing visualization_msgs/Marker messages. Create a new file named dummy_marker.py in the ~/ros2_ws/src/ros2_course/ros2_course folder. Add it to the setup.py , as usually. Copy the following code into the file dummy_marker.py : import rclpy from rclpy.node import Node from visualization_msgs.msg import Marker class DummyMarker ( Node ): def __init__ ( self , position ): super () . __init__ ( 'minimal_publisher' ) self . position = position self . publisher_ = self . create_publisher ( Marker , 'dummy_target_marker' , 10 ) timer_period = 0.1 # seconds self . timer = self . create_timer ( timer_period , self . timer_callback ) self . i = 0 i = 0 def timer_callback ( self ): marker = Marker () marker . header . frame_id = 'PSM1_psm_base_link' marker . header . stamp = self . get_clock () . now () . to_msg () marker . ns = \"dvrk_viz\" marker . id = self . i marker . type = Marker . SPHERE marker . action = Marker . MODIFY marker . pose . position . x = self . position [ 0 ] marker . pose . position . y = self . position [ 1 ] marker . pose . position . z = self . position [ 2 ] marker . pose . orientation . x = 0.0 marker . pose . orientation . y = 0.0 marker . pose . orientation . z = 0.0 marker . pose . orientation . w = 1.0 marker . scale . x = 0.008 marker . scale . y = 0.008 marker . scale . z = 0.008 marker . color . a = 1.0 # Don't forget to set the alpha! marker . color . r = 0.0 marker . color . g = 1.0 marker . color . b = 0.0 ; self . publisher_ . publish ( marker ) self . i += 1 def main ( args = None ): rclpy . init ( args = args ) marker_publisher = DummyMarker ([ - 0.05 , 0.08 , - 0.12 ]) rclpy . spin ( marker_publisher ) # Destroy the node explicitly # (optional - otherwise it will be done automatically # when the garbage collector destroys the node object) marker_publisher . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Build and run the node. Visualize the marker in RViz.","title":"4. Dummy marker"},{"location":"04_da_vinci/#5-grasp-the-marker","text":"Subscribe to the topic with the marker position dummy_target_publisher the file psm_grasp.py . Implement a method in psm_grasp.py to grasp the generated marker with PSM1. Note Some values tends to stuck in the simulator. Thus, at the beginning of the program, it is a good idea to reset the arm: #Reset the arm psm . move_tcp_to ([ 0.0 , 0.0 , - 0.12 ], 0.01 , 0.01 ) psm . move_jaw_to ( 0.0 , 0.1 , 0.01 )","title":"5. Grasp the marker"},{"location":"04_da_vinci/#links","text":"Download and compile dVRK 2 Marker examples Numpy vector magnitude Numpy linspace","title":"Links"},{"location":"05_roslaunch/","text":"05. ROS 2 Launch, Param, Bag Lecture ROS 2 Launch Launch multiple nodes Set arguments Monitor running nodes React on changes in the state of nodes Python, XML and YAML file formats Usage ros2 launch package_name file.launch ros2 launch irob_robot dvrk_server.launch arm_typ: = PSM1 ROS 2 Parameters Configure nodes at startup or during runtime without changing the code Associated with individual nodes Consists of: key, value, descriptor Available data types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. Useful command: ros2 param ROS 2 Bag Record and playback ROS topics Command line tool API for C++ and Python ros2 bag record -o <file_name> <topic_name> ros2 bag record --all ros2 bag info <filename.bag> ros2 bag play <filename.bag> Practice 1: Launch Turtlesim Mimic Create the launch folder inside the ros2_course package, where the launch files can be stored: cd ~/ros2_ws/src/ros2_course mkdir launch Create the turtlesim_mimic_launch.py file in the new launch folder a with the following content: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'turtlesim' , namespace = 'turtlesim1' , executable = 'turtlesim_node' , name = 'sim' ), Node ( package = 'turtlesim' , namespace = 'turtlesim2' , executable = 'turtlesim_node' , name = 'sim' ), Node ( package = 'turtlesim' , executable = 'mimic' , name = 'mimic' , remappings = [ ( '/input/pose' , '/turtlesim1/turtle1/pose' ), ( '/output/cmd_vel' , '/turtlesim2/turtle1/cmd_vel' ), ] ) ]) Add the followings to the setup.py file: import os from glob import glob # ... data_files =[ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]) , ( 'share/' + package_name, [ 'package.xml' ]) , # Include all launch files. ( os.path.join ( 'share' , package_name ) , glob ( 'launch/*launch.[pxy][yma]*' )) ] , Add the ros2launch dependency to the package.xml file: <exec_depend>ros2launch</exec_depend> Build the workspace: cd ros2_ws colcon build --symlink-install Launch the launch file: ros2 launch ros2_course turtlesim_mimic_launch.py Publish to the topic from the command line, in a new terminal window: ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}\" Let's examine the operation of the system using rqt_gui : ros2 run rqt_gui rqt_gui 2: Launch Turtlesim Goto Let's make a copy of turtlesim_mimic_launch.py from a file named turtlesim_controller_launch.py . Add the turtlesim_controller node written in the previous lesson to the launch file, so the first turtle is controlled by this node, and the second copies its movement. The turtle to be controlled can be set using namespace or remappings . Build the workspace: cd ros2_ws colcon build --symlink-install launch the new launch file: ros2 launch ros2_course turtlesim_controller_launch.py 3: Turtlesim controller params Modify turtlesim_controller so that the linear velocity and angular velocity. is adjustable via ROS parameters. API example for parameters: import rclpy import rclpy.node class MinimalParam ( rclpy . node . Node ): def __init__ ( self ): super () . __init__ ( 'minimal_param_node' ) # Declare parameter named 'my_parameter' and # set default value to 'world' self . declare_parameter ( 'my_parameter' , 'world' ) self . timer = self . create_timer ( 1 , self . timer_callback ) def timer_callback ( self ): my_param = self . get_parameter ( 'my_parameter' ) . get_parameter_value () . string_value self . get_logger () . info ( 'Hello %s !' % my_param ) def main (): rclpy . init () node = MinimalParam () rclpy . spin ( node ) if __name__ == '__main__' : main () Let's run turtlesim_controller.py using the previously written launch file. Let's list the parameters. ros2 launch ros2_course turtlesim_controller_launch.py ros2 param list Change the speed and angular velocity parameters from the command line using the following command: ros2 param set <NODE_NAME> <PARAM_NAME> <NEW_VALUE> ros2 param set controller speed 100 .0 Bonus 1: Turtlesim controller launch and substitutions Let's make a copy of turtlesim_controller_launch.py as turtlesim_controller_param_launch.py . Modify the new launch file based on the example below so that the velocity and angular velocity parameters of the launch can be specified as file arguments. from launch_ros.actions import Node from launch import LaunchDescription from launch.actions import DeclareLaunchArgument , ExecuteProcess , TimerAction from launch.conditions import IfCondition from launch.substitutions import LaunchConfiguration , PythonExpression def generate_launch_description (): turtlesim_ns_launch_arg = DeclareLaunchArgument ( 'turtlesim_ns' , default_value = 'turtlesim1' , description = 'Namespace for turtle 1' ) use_provided_red_launch_arg = DeclareLaunchArgument ( 'use_provided_red' , default_value = 'False' ) new_background_r_launch_arg = DeclareLaunchArgument ( 'new_background_r' , default_value = '200' ) background_g_launch_arg = DeclareLaunchArgument ( 'background_g' , default_value = '100' ) background_b_launch_arg = DeclareLaunchArgument ( 'background_b' , default_value = '100' ) turtlesim_ns_value = LaunchConfiguration ( 'turtlesim_ns' ) use_provided_red_value = LaunchConfiguration ( 'use_provided_red' ) new_background_r_value = LaunchConfiguration ( 'new_background_r' ) background_g_value = LaunchConfiguration ( 'background_g' ) background_b_value = LaunchConfiguration ( 'background_b' ) turtlesim_node = Node ( package = 'turtlesim' , namespace = turtlesim_ns_value , executable = 'turtlesim_node' , name = 'sim' , parameters = [{ 'background_g' : background_g_value , 'background_b' : background_b_value , }] ) spawn_turtle = ExecuteProcess ( cmd = [[ 'ros2 service call ' , turtlesim_ns , '/spawn ' , 'turtlesim/srv/Spawn ' , '\"{x: 2, y: 2, theta: 0.2}\"' ]], shell = True ) change_background_r = ExecuteProcess ( cmd = [[ 'ros2 param set ' , turtlesim_ns , '/sim background_r ' , '120' ]], shell = True ) change_background_r_conditioned = ExecuteProcess ( condition = IfCondition ( PythonExpression ([ new_background_r_value , ' == 200' , ' and ' , use_provided_red ]) ), cmd = [[ 'ros2 param set ' , turtlesim_ns_value , '/sim background_r ' , new_background_r ]], shell = True ) return LaunchDescription ([ turtlesim_ns_launch_arg , use_provided_red_launch_arg , new_background_r_launch_arg , turtlesim_node , spawn_turtle , change_background_r , TimerAction ( period = 2.0 , actions = [ change_background_r_conditioned ], ) ]) Build the workspace and run turtlesim_controller_param_launch.py : cd ros2_ws colcon build --symlink-install ros2 launch ros2_course turtlesim_controller_param_launch.py Let's list the arguments of the new launch file: ros2 launch ros2_course turtlesim_controller_param_launch.py --show-args Run the launch file by setting the arguments: ros2 launch ros2_course turtlesim_controller_param_launch.py speed: = 100 .0 omega: = 60 .0 Using the example above, let's set the background color also using command line argument(s). Bonus 2: Rosbag While the program implemented in the previous exercise is running, record the contents of the topics in a rosbag file. ros2 bag record --all Syntax The filename and the topics to record can also be set, e.g.: ros2 bag record -o turtle_bagfile_1 /turtle1/cmd_vel /turtle1/pose Use the following command to query the properties of the bag file: ros2 bag info <PATH_TO_BAGFILE> Play back the bag file and plot the pose/x value of one of the turtles on a graph using rqt_gui . ros2 bag info <PATH_TO_BAGFILE> ros2 run rqt_gui rqt_gui Useful links ROS 2 Launch Tutorial ROS 2 Parameters Using ROS 2 parameters in a Class ROS 2 Bag","title":"5. Roslaunch, msg, action, service"},{"location":"05_roslaunch/#05-ros-2-launch-param-bag","text":"","title":"05. ROS 2 Launch, Param, Bag"},{"location":"05_roslaunch/#lecture","text":"","title":"Lecture"},{"location":"05_roslaunch/#ros-2-launch","text":"Launch multiple nodes Set arguments Monitor running nodes React on changes in the state of nodes Python, XML and YAML file formats","title":"ROS 2 Launch"},{"location":"05_roslaunch/#usage","text":"ros2 launch package_name file.launch ros2 launch irob_robot dvrk_server.launch arm_typ: = PSM1","title":"Usage"},{"location":"05_roslaunch/#ros-2-parameters","text":"Configure nodes at startup or during runtime without changing the code Associated with individual nodes Consists of: key, value, descriptor Available data types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. Useful command: ros2 param","title":"ROS 2 Parameters"},{"location":"05_roslaunch/#ros-2-bag","text":"Record and playback ROS topics Command line tool API for C++ and Python ros2 bag record -o <file_name> <topic_name> ros2 bag record --all ros2 bag info <filename.bag> ros2 bag play <filename.bag>","title":"ROS 2 Bag"},{"location":"05_roslaunch/#practice","text":"","title":"Practice"},{"location":"05_roslaunch/#1-launch-turtlesim-mimic","text":"Create the launch folder inside the ros2_course package, where the launch files can be stored: cd ~/ros2_ws/src/ros2_course mkdir launch Create the turtlesim_mimic_launch.py file in the new launch folder a with the following content: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'turtlesim' , namespace = 'turtlesim1' , executable = 'turtlesim_node' , name = 'sim' ), Node ( package = 'turtlesim' , namespace = 'turtlesim2' , executable = 'turtlesim_node' , name = 'sim' ), Node ( package = 'turtlesim' , executable = 'mimic' , name = 'mimic' , remappings = [ ( '/input/pose' , '/turtlesim1/turtle1/pose' ), ( '/output/cmd_vel' , '/turtlesim2/turtle1/cmd_vel' ), ] ) ]) Add the followings to the setup.py file: import os from glob import glob # ... data_files =[ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]) , ( 'share/' + package_name, [ 'package.xml' ]) , # Include all launch files. ( os.path.join ( 'share' , package_name ) , glob ( 'launch/*launch.[pxy][yma]*' )) ] , Add the ros2launch dependency to the package.xml file: <exec_depend>ros2launch</exec_depend> Build the workspace: cd ros2_ws colcon build --symlink-install Launch the launch file: ros2 launch ros2_course turtlesim_mimic_launch.py Publish to the topic from the command line, in a new terminal window: ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}\" Let's examine the operation of the system using rqt_gui : ros2 run rqt_gui rqt_gui","title":"1: Launch Turtlesim Mimic"},{"location":"05_roslaunch/#2-launch-turtlesim-goto","text":"Let's make a copy of turtlesim_mimic_launch.py from a file named turtlesim_controller_launch.py . Add the turtlesim_controller node written in the previous lesson to the launch file, so the first turtle is controlled by this node, and the second copies its movement. The turtle to be controlled can be set using namespace or remappings . Build the workspace: cd ros2_ws colcon build --symlink-install launch the new launch file: ros2 launch ros2_course turtlesim_controller_launch.py","title":"2: Launch Turtlesim Goto"},{"location":"05_roslaunch/#3-turtlesim-controller-params","text":"Modify turtlesim_controller so that the linear velocity and angular velocity. is adjustable via ROS parameters. API example for parameters: import rclpy import rclpy.node class MinimalParam ( rclpy . node . Node ): def __init__ ( self ): super () . __init__ ( 'minimal_param_node' ) # Declare parameter named 'my_parameter' and # set default value to 'world' self . declare_parameter ( 'my_parameter' , 'world' ) self . timer = self . create_timer ( 1 , self . timer_callback ) def timer_callback ( self ): my_param = self . get_parameter ( 'my_parameter' ) . get_parameter_value () . string_value self . get_logger () . info ( 'Hello %s !' % my_param ) def main (): rclpy . init () node = MinimalParam () rclpy . spin ( node ) if __name__ == '__main__' : main () Let's run turtlesim_controller.py using the previously written launch file. Let's list the parameters. ros2 launch ros2_course turtlesim_controller_launch.py ros2 param list Change the speed and angular velocity parameters from the command line using the following command: ros2 param set <NODE_NAME> <PARAM_NAME> <NEW_VALUE> ros2 param set controller speed 100 .0","title":"3: Turtlesim controller params"},{"location":"05_roslaunch/#bonus-1-turtlesim-controller-launch-and-substitutions","text":"Let's make a copy of turtlesim_controller_launch.py as turtlesim_controller_param_launch.py . Modify the new launch file based on the example below so that the velocity and angular velocity parameters of the launch can be specified as file arguments. from launch_ros.actions import Node from launch import LaunchDescription from launch.actions import DeclareLaunchArgument , ExecuteProcess , TimerAction from launch.conditions import IfCondition from launch.substitutions import LaunchConfiguration , PythonExpression def generate_launch_description (): turtlesim_ns_launch_arg = DeclareLaunchArgument ( 'turtlesim_ns' , default_value = 'turtlesim1' , description = 'Namespace for turtle 1' ) use_provided_red_launch_arg = DeclareLaunchArgument ( 'use_provided_red' , default_value = 'False' ) new_background_r_launch_arg = DeclareLaunchArgument ( 'new_background_r' , default_value = '200' ) background_g_launch_arg = DeclareLaunchArgument ( 'background_g' , default_value = '100' ) background_b_launch_arg = DeclareLaunchArgument ( 'background_b' , default_value = '100' ) turtlesim_ns_value = LaunchConfiguration ( 'turtlesim_ns' ) use_provided_red_value = LaunchConfiguration ( 'use_provided_red' ) new_background_r_value = LaunchConfiguration ( 'new_background_r' ) background_g_value = LaunchConfiguration ( 'background_g' ) background_b_value = LaunchConfiguration ( 'background_b' ) turtlesim_node = Node ( package = 'turtlesim' , namespace = turtlesim_ns_value , executable = 'turtlesim_node' , name = 'sim' , parameters = [{ 'background_g' : background_g_value , 'background_b' : background_b_value , }] ) spawn_turtle = ExecuteProcess ( cmd = [[ 'ros2 service call ' , turtlesim_ns , '/spawn ' , 'turtlesim/srv/Spawn ' , '\"{x: 2, y: 2, theta: 0.2}\"' ]], shell = True ) change_background_r = ExecuteProcess ( cmd = [[ 'ros2 param set ' , turtlesim_ns , '/sim background_r ' , '120' ]], shell = True ) change_background_r_conditioned = ExecuteProcess ( condition = IfCondition ( PythonExpression ([ new_background_r_value , ' == 200' , ' and ' , use_provided_red ]) ), cmd = [[ 'ros2 param set ' , turtlesim_ns_value , '/sim background_r ' , new_background_r ]], shell = True ) return LaunchDescription ([ turtlesim_ns_launch_arg , use_provided_red_launch_arg , new_background_r_launch_arg , turtlesim_node , spawn_turtle , change_background_r , TimerAction ( period = 2.0 , actions = [ change_background_r_conditioned ], ) ]) Build the workspace and run turtlesim_controller_param_launch.py : cd ros2_ws colcon build --symlink-install ros2 launch ros2_course turtlesim_controller_param_launch.py Let's list the arguments of the new launch file: ros2 launch ros2_course turtlesim_controller_param_launch.py --show-args Run the launch file by setting the arguments: ros2 launch ros2_course turtlesim_controller_param_launch.py speed: = 100 .0 omega: = 60 .0 Using the example above, let's set the background color also using command line argument(s).","title":"Bonus 1: Turtlesim controller launch and substitutions"},{"location":"05_roslaunch/#bonus-2-rosbag","text":"While the program implemented in the previous exercise is running, record the contents of the topics in a rosbag file. ros2 bag record --all Syntax The filename and the topics to record can also be set, e.g.: ros2 bag record -o turtle_bagfile_1 /turtle1/cmd_vel /turtle1/pose Use the following command to query the properties of the bag file: ros2 bag info <PATH_TO_BAGFILE> Play back the bag file and plot the pose/x value of one of the turtles on a graph using rqt_gui . ros2 bag info <PATH_TO_BAGFILE> ros2 run rqt_gui rqt_gui","title":"Bonus 2: Rosbag"},{"location":"05_roslaunch/#useful-links","text":"ROS 2 Launch Tutorial ROS 2 Parameters Using ROS 2 parameters in a Class ROS 2 Bag","title":"Useful links"},{"location":"06_robotics_principles/","text":"06. Kinematics, inverse kinematics, Programming of a simulated robotic arm Warning Test 2 on December 8. Rehearsal 3D transformations Position: 3 element offset vector Orientation: 3 x 3 rotation matrix additional orientation representations: Euler angles, RPY, angle axis, quaternion Pose: 4 \u00d7 4 transformation matrix Coordinate frame: origin, 3 axis, 3 base vector, right-hand rule Homogeneous transformations: rotation and translation together e.g. \\(\\mathbf{R}\\) for rotation and \\(\\mathbf{v}\\) for translation: \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right] = \\left[\\matrix{r_{1,1} & r_{1,2} & r_{1,3} & v_x\\\\r_{2,1} & r_{2,2} & r_{2,3} & v_y\\\\r_{3,1} & r_{3,2} & r_{3,3} & v_z\\\\\\ 0 & 0 & 0 & 1 }\\right] \\] Homogeneous coordinates: Vector: add 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\) Point: add 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\) Applying transformations is simpler: \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] Degree of freedom (DoF): number of independent variables (quantities). Robotics basics Robot structure: segments (link) and joints Task space (Cartesian space): Three-dimensional space where the task, trajectories, obstacles, etc. are defined. TCP (Tool Center Point): coordinate frame fixed to the end effector Base/world frame Joint space : Quantities assigned to the robot's joints, which can be interpreted by the robot's low-level control system. Joint angles, velocities, accelerations, torques... Lecture Kinematics, inverse kinematics Kinematics Def. Kinematics Calculating the pose of the TCP (or anything else) from the joint coordinates. Kinematic model Denavit--Hartenberg (DH) convention URDF (Unified Robotics Description Format, XML-based) If the coordinate systems assigned to the segments are \\(base, 1, 2, 3, ..., TCP\\) , the transfomrms between adjacent segments \\(i\\) and \\(i+1\\) are \\(T_{i+1,i}(q_{i+1})\\) (which is a function of the angle of the joint between them), the transfomrs between the base frame and TCP can be written as (for a robot with \\(n\\) joints): \\[ T_{TCP,base}(q_1, \\cdots, q_n) = T_{TCP,n-1}(q_{n}) \\cdot T_{n-1,n-2}(q_{n-1}) \\cdots T_{2,1}(q_2) \\cdot T_{1,base}(q_1) \\cdot base \\] Inverse kinematics Def. Inverse kinematics Calculate the joint coordinates to achieve (desired) TCP (or any other) pose. Differential inverse kinematics Def. Differential inverse kinematics Which change in the joint coordinates achieves the desired small change in the TCP pose (rotation and translation). Jacobi matrix (Jacobian): a matrix of first-order partial derivatives of a vector-valued function. \\[ \\mathbf{J} = \\left[\\matrix{\\frac{\\partial x_1}{\\partial q_1} & \\frac{\\partial x_1}{\\partial q_2} &\\frac{\\partial x_1}{\\partial q_3} & \\dots &\\frac{\\partial x_1}{\\partial q_n} \\\\ \\frac{\\partial x_2}{\\partial q_1} & \\frac{\\partial x_2}{\\partial q_2} &\\frac{\\partial x_2} {\\partial q_3} & \\dots &\\frac{\\partial x_2}{\\partial q_n} \\\\ \\frac{\\partial x_3}{\\partial q_1} & \\frac{\\partial x_3}{\\partial q_2} &\\frac{\\partial x_3}{\\partial q_3} & \\dots &\\frac{\\partial x_3}{\\partial q_n} \\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\ \\frac{\\partial x_m}{\\partial q_1} & \\frac{\\partial x_m}{\\partial q_2} &\\frac{\\partial x_m}{\\partial q_3} & \\dots &\\frac{\\partial x_m}{\\partial q_n} \\\\}\\right] \\] Jacobi matrix significance in robotics : gives the relationship between joint velocities and TCP velocity. \\[ \\left[\\matrix{\\mathbf{v} \\\\ \\mathbf{\\omega}}\\right] =\\mathbf{J}(\\mathbf{q})\\cdot \\mathbf{\\dot{q}} \\] ,where \\(\\mathbf{v}\\) is the linear velocity of the TCP, \\(\\mathbf{\\omega}\\) is the angular velocity of the TCP, and \\(\\mathbf{q}\\) is the configuration of the robot. Def. Configuration The vector or array containing the current joint angles of the robot. Inverse kinematics using Jacobian inverse Calculate the difference between the desired and the current position: \\(\\Delta\\mathbf{r} = \\mathbf{r}_{desired} - \\mathbf{r}_0\\) Calculate the difference in rotations: \\(\\Delta\\mathbf{R} = \\mathbf{R}_{desired}\\mathbf{R}_{0}^{T}\\) , then convert to axis angle representation \\((\\mathbf{t},\\phi)\\) Compute \\(\\Delta\\mathbf{ q}=\\mathbf{J}^{-1}(\\mathbf{q_0})\\cdot \\left[\\matrix{k_1 \\cdot \\Delta\\mathbf{r} \\\\ k_2 \\cdot \\mathbf{\\omega}}\\right]\\) , where the inverse can be pseudo-inverse or transposed \\(\\mathbf{q}_{better} = \\mathbf{q}_{0} + \\Delta\\mathbf{q}\\) Exercise 1: UR install Install the dependencies and the UR driver. sudo apt update sudo apt upgrade sudo apt-get install ros-humble-ur python3-pip pip3 install kinpy Tip Also download the source of the kinpy package, it might be useful for understanding the API: https://pypi.org/project/kinpy/ Download the zip containing your source files from Moodle ( ur_ros2_course.zip ). Copy the view_ur.launch.py file to the ros2_course/launch folder, and topic_latcher.py to ros2_course/ros2_course . Add the following lines to setup.py (launch and entry point): import os from glob import glob # ... data_files =[ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]) , ( 'share/' + package_name, [ 'package.xml' ]) , # Include all launch files. ( os.path.join ( 'share' , package_name ) , glob ( 'launch/*launch.[pxy][yma]*' )) ] , # ... entry_points ={ 'console_scripts' : [ # ... 'topic_latcher = ros2_course.topic_latcher:main' , ] , Add the ros2launch dependency to the package.xml file: <exec_depend>ros2launch</exec_depend> Build the workspace as usual: cd ~/ros2_ws colcon build --symlink-install Start the simulator, move the joints using the Joint State Publisher GUI. ros2 launch ros2_course view_ur.launch.py ur_type: = ur5e Tip Try other robots using argument ur_type (ur3, ur3e, ur5, ur5e, ur10, ur10e, ur16e, ur20). 2: Move the robot in joint space Create a new python source file named ur_controller.py in ~/ros2_ws/src/ros2_course/ros2_course folder. Specify the new entry point in setup.py in the usual way. Subscribe to the topic publishing the robot's joint angles (configuration). Create publisher for the topic that can be used to set the joint angles. /joint_states /set_joint_states Move the robot to the configuration q = [-1.28, 4.41, 1.54, -1.16, -1.56, 0.0] . 3. Kinematics The simulator publishes the urdf description of the robot in a topic. Subscribe to this topic. /robot_description_latch Import the kinpy package and create the kinematic chain based on the urdf describing the robot in the callback function just implemented: import kinpy as kp # ... self . chain = kp . build_serial_chain_from_urdf ( self . desc , 'tool0' ) print ( self . chain . get_joint_parameter_names ()) print ( self . chain ) Calculate and print the TCP pose in the given configuration using the kinpy package. p = chain . forward_kinematics ( q ) 4: Inverse kinematics with Jacobian inverse method Write a method that implements the inverse kinematics problem on the robot using the Jacobian inverse method presented in the lecture. The orientation is ignored. Move the TCP to the position (0.50, -0.60, 0.20) . Write a loop with a stop condition for the length of delta_r and rclpy.ok() . Calculate the difference between the desired and the current TCP positions ( delta_r ). Scale with the constant k_1 . Set omega to [0.0, 0.0, 0.0] (ignore orientation). Concatenate delta_r and omega . Calculate the Jacobian matrix in the given configuration using the function kp.jacobian.calc_jacobian(...) . Calculate the pseudo-inverse of the Jacobian matrix np.linalg.pinv(...) . Calculate delta_q using the above formula. Increment the joint angles with the obtained values. Plot the TCP trajectory using Matplotlib. import matplotlib.pyplot as plt # ... # Plot trajectory ax = plt . figure () . add_subplot ( projection = '3d' ) ax . plot ( x , y , z , label = 'TCP trajectory' , ls = '-' , marker = '.' ) ax . legend () ax . set_xlabel ( 'x [m]' ) ax . set_ylabel ( 'y [m]' ) ax . set_zlabel ( 'z [m]' ) plt . show () Bonus: Inverse kinematics with orientation Complete the solution to the previous problem by including orientation in the inverse kinematics calculation. Useful links https://github.com/UniversalRobots/Universal_Robots_ROS2_Driver/tree/humble https://docs.ros.org/en/ros2_packages/humble/api/ur_robot_driver/usage.html#usage-with-official-ur-simulator https://github.com/UniversalRobots/Universal_Robots_Client_Library https://pypi.org/project/kinpy/ https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation https://www.rosroboticslearning.com/jacobian","title":"6. Kinematics, inverse kinematics"},{"location":"06_robotics_principles/#06-kinematics-inverse-kinematics-programming-of-a-simulated-robotic-arm","text":"Warning Test 2 on December 8.","title":"06. Kinematics, inverse kinematics, Programming of a simulated robotic arm"},{"location":"06_robotics_principles/#rehearsal","text":"","title":"Rehearsal"},{"location":"06_robotics_principles/#3d-transformations","text":"Position: 3 element offset vector Orientation: 3 x 3 rotation matrix additional orientation representations: Euler angles, RPY, angle axis, quaternion Pose: 4 \u00d7 4 transformation matrix Coordinate frame: origin, 3 axis, 3 base vector, right-hand rule Homogeneous transformations: rotation and translation together e.g. \\(\\mathbf{R}\\) for rotation and \\(\\mathbf{v}\\) for translation: \\[ \\mathbf{T} = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right] = \\left[\\matrix{r_{1,1} & r_{1,2} & r_{1,3} & v_x\\\\r_{2,1} & r_{2,2} & r_{2,3} & v_y\\\\r_{3,1} & r_{3,2} & r_{3,3} & v_z\\\\\\ 0 & 0 & 0 & 1 }\\right] \\] Homogeneous coordinates: Vector: add 0, \\(\\mathbf{a_H}=\\left[\\matrix{\\mathbf{a} \\\\ 0}\\right]=\\left[\\matrix{a_x \\\\ a_y \\\\ a_z \\\\ 0}\\right]\\) Point: add 1, \\(\\mathbf{p_H}=\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right]=\\left[\\matrix{p_x \\\\ p_y \\\\ p_z \\\\ 1}\\right]\\) Applying transformations is simpler: \\[ \\mathbf{q} = \\mathbf{R}\\mathbf{p} + \\mathbf{v} \\to \\left[\\matrix{\\mathbf{q} \\\\ 1}\\right] = \\left[\\matrix{\\mathbf{R} & \\mathbf{v}\\\\\\mathbf{0} & 1 }\\right]\\left[\\matrix{\\mathbf{p} \\\\ 1}\\right] \\] Degree of freedom (DoF): number of independent variables (quantities).","title":"3D transformations"},{"location":"06_robotics_principles/#robotics-basics","text":"Robot structure: segments (link) and joints Task space (Cartesian space): Three-dimensional space where the task, trajectories, obstacles, etc. are defined. TCP (Tool Center Point): coordinate frame fixed to the end effector Base/world frame Joint space : Quantities assigned to the robot's joints, which can be interpreted by the robot's low-level control system. Joint angles, velocities, accelerations, torques...","title":"Robotics basics"},{"location":"06_robotics_principles/#lecture","text":"","title":"Lecture"},{"location":"06_robotics_principles/#kinematics-inverse-kinematics","text":"","title":"Kinematics, inverse kinematics"},{"location":"06_robotics_principles/#kinematics","text":"Def. Kinematics Calculating the pose of the TCP (or anything else) from the joint coordinates. Kinematic model Denavit--Hartenberg (DH) convention URDF (Unified Robotics Description Format, XML-based) If the coordinate systems assigned to the segments are \\(base, 1, 2, 3, ..., TCP\\) , the transfomrms between adjacent segments \\(i\\) and \\(i+1\\) are \\(T_{i+1,i}(q_{i+1})\\) (which is a function of the angle of the joint between them), the transfomrs between the base frame and TCP can be written as (for a robot with \\(n\\) joints): \\[ T_{TCP,base}(q_1, \\cdots, q_n) = T_{TCP,n-1}(q_{n}) \\cdot T_{n-1,n-2}(q_{n-1}) \\cdots T_{2,1}(q_2) \\cdot T_{1,base}(q_1) \\cdot base \\]","title":"Kinematics"},{"location":"06_robotics_principles/#inverse-kinematics","text":"Def. Inverse kinematics Calculate the joint coordinates to achieve (desired) TCP (or any other) pose.","title":"Inverse kinematics"},{"location":"06_robotics_principles/#differential-inverse-kinematics","text":"Def. Differential inverse kinematics Which change in the joint coordinates achieves the desired small change in the TCP pose (rotation and translation). Jacobi matrix (Jacobian): a matrix of first-order partial derivatives of a vector-valued function. \\[ \\mathbf{J} = \\left[\\matrix{\\frac{\\partial x_1}{\\partial q_1} & \\frac{\\partial x_1}{\\partial q_2} &\\frac{\\partial x_1}{\\partial q_3} & \\dots &\\frac{\\partial x_1}{\\partial q_n} \\\\ \\frac{\\partial x_2}{\\partial q_1} & \\frac{\\partial x_2}{\\partial q_2} &\\frac{\\partial x_2} {\\partial q_3} & \\dots &\\frac{\\partial x_2}{\\partial q_n} \\\\ \\frac{\\partial x_3}{\\partial q_1} & \\frac{\\partial x_3}{\\partial q_2} &\\frac{\\partial x_3}{\\partial q_3} & \\dots &\\frac{\\partial x_3}{\\partial q_n} \\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\ \\frac{\\partial x_m}{\\partial q_1} & \\frac{\\partial x_m}{\\partial q_2} &\\frac{\\partial x_m}{\\partial q_3} & \\dots &\\frac{\\partial x_m}{\\partial q_n} \\\\}\\right] \\] Jacobi matrix significance in robotics : gives the relationship between joint velocities and TCP velocity. \\[ \\left[\\matrix{\\mathbf{v} \\\\ \\mathbf{\\omega}}\\right] =\\mathbf{J}(\\mathbf{q})\\cdot \\mathbf{\\dot{q}} \\] ,where \\(\\mathbf{v}\\) is the linear velocity of the TCP, \\(\\mathbf{\\omega}\\) is the angular velocity of the TCP, and \\(\\mathbf{q}\\) is the configuration of the robot. Def. Configuration The vector or array containing the current joint angles of the robot.","title":"Differential inverse kinematics"},{"location":"06_robotics_principles/#inverse-kinematics-using-jacobian-inverse","text":"Calculate the difference between the desired and the current position: \\(\\Delta\\mathbf{r} = \\mathbf{r}_{desired} - \\mathbf{r}_0\\) Calculate the difference in rotations: \\(\\Delta\\mathbf{R} = \\mathbf{R}_{desired}\\mathbf{R}_{0}^{T}\\) , then convert to axis angle representation \\((\\mathbf{t},\\phi)\\) Compute \\(\\Delta\\mathbf{ q}=\\mathbf{J}^{-1}(\\mathbf{q_0})\\cdot \\left[\\matrix{k_1 \\cdot \\Delta\\mathbf{r} \\\\ k_2 \\cdot \\mathbf{\\omega}}\\right]\\) , where the inverse can be pseudo-inverse or transposed \\(\\mathbf{q}_{better} = \\mathbf{q}_{0} + \\Delta\\mathbf{q}\\)","title":"Inverse kinematics using Jacobian inverse"},{"location":"06_robotics_principles/#exercise","text":"","title":"Exercise"},{"location":"06_robotics_principles/#1-ur-install","text":"Install the dependencies and the UR driver. sudo apt update sudo apt upgrade sudo apt-get install ros-humble-ur python3-pip pip3 install kinpy Tip Also download the source of the kinpy package, it might be useful for understanding the API: https://pypi.org/project/kinpy/ Download the zip containing your source files from Moodle ( ur_ros2_course.zip ). Copy the view_ur.launch.py file to the ros2_course/launch folder, and topic_latcher.py to ros2_course/ros2_course . Add the following lines to setup.py (launch and entry point): import os from glob import glob # ... data_files =[ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]) , ( 'share/' + package_name, [ 'package.xml' ]) , # Include all launch files. ( os.path.join ( 'share' , package_name ) , glob ( 'launch/*launch.[pxy][yma]*' )) ] , # ... entry_points ={ 'console_scripts' : [ # ... 'topic_latcher = ros2_course.topic_latcher:main' , ] , Add the ros2launch dependency to the package.xml file: <exec_depend>ros2launch</exec_depend> Build the workspace as usual: cd ~/ros2_ws colcon build --symlink-install Start the simulator, move the joints using the Joint State Publisher GUI. ros2 launch ros2_course view_ur.launch.py ur_type: = ur5e Tip Try other robots using argument ur_type (ur3, ur3e, ur5, ur5e, ur10, ur10e, ur16e, ur20).","title":"1: UR install"},{"location":"06_robotics_principles/#2-move-the-robot-in-joint-space","text":"Create a new python source file named ur_controller.py in ~/ros2_ws/src/ros2_course/ros2_course folder. Specify the new entry point in setup.py in the usual way. Subscribe to the topic publishing the robot's joint angles (configuration). Create publisher for the topic that can be used to set the joint angles. /joint_states /set_joint_states Move the robot to the configuration q = [-1.28, 4.41, 1.54, -1.16, -1.56, 0.0] .","title":"2: Move the robot in joint space"},{"location":"06_robotics_principles/#3-kinematics","text":"The simulator publishes the urdf description of the robot in a topic. Subscribe to this topic. /robot_description_latch Import the kinpy package and create the kinematic chain based on the urdf describing the robot in the callback function just implemented: import kinpy as kp # ... self . chain = kp . build_serial_chain_from_urdf ( self . desc , 'tool0' ) print ( self . chain . get_joint_parameter_names ()) print ( self . chain ) Calculate and print the TCP pose in the given configuration using the kinpy package. p = chain . forward_kinematics ( q )","title":"3. Kinematics"},{"location":"06_robotics_principles/#4-inverse-kinematics-with-jacobian-inverse-method","text":"Write a method that implements the inverse kinematics problem on the robot using the Jacobian inverse method presented in the lecture. The orientation is ignored. Move the TCP to the position (0.50, -0.60, 0.20) . Write a loop with a stop condition for the length of delta_r and rclpy.ok() . Calculate the difference between the desired and the current TCP positions ( delta_r ). Scale with the constant k_1 . Set omega to [0.0, 0.0, 0.0] (ignore orientation). Concatenate delta_r and omega . Calculate the Jacobian matrix in the given configuration using the function kp.jacobian.calc_jacobian(...) . Calculate the pseudo-inverse of the Jacobian matrix np.linalg.pinv(...) . Calculate delta_q using the above formula. Increment the joint angles with the obtained values. Plot the TCP trajectory using Matplotlib. import matplotlib.pyplot as plt # ... # Plot trajectory ax = plt . figure () . add_subplot ( projection = '3d' ) ax . plot ( x , y , z , label = 'TCP trajectory' , ls = '-' , marker = '.' ) ax . legend () ax . set_xlabel ( 'x [m]' ) ax . set_ylabel ( 'y [m]' ) ax . set_zlabel ( 'z [m]' ) plt . show ()","title":"4: Inverse kinematics with Jacobian inverse method"},{"location":"06_robotics_principles/#bonus-inverse-kinematics-with-orientation","text":"Complete the solution to the previous problem by including orientation in the inverse kinematics calculation.","title":"Bonus: Inverse kinematics with orientation"},{"location":"06_robotics_principles/#useful-links","text":"https://github.com/UniversalRobots/Universal_Robots_ROS2_Driver/tree/humble https://docs.ros.org/en/ros2_packages/humble/api/ur_robot_driver/usage.html#usage-with-official-ur-simulator https://github.com/UniversalRobots/Universal_Robots_Client_Library https://pypi.org/project/kinpy/ https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation https://www.rosroboticslearning.com/jacobian","title":"Useful links"},{"location":"07_git/","text":"07. Versioning, Git Warning Test 2 on December 8. Lecture Version control, Git Track changes in a set of files Coordinating work among developers Who made what changes and when Revert back at any time Local and remote repos Take snapshots of files by making a commit Install sudo apt install git Basic commands git init # Initialize local git repo git add <file> # Add file/files to staging area git status # Check status of working tree and staging area git commit -m \"What I've done\" # Commit changes in index git push # Push to remote repository git pull # Pull latest changes from remote repo git branch <new_branch_name> git checkout <branch_name> git merge <branch_name> # Merge the branch into the current branch git config --global user.name \"Istvan Szabo\" git config --global user.email \"istvan.szabo@gmail.com\" Tip Store personal token: git config --global credential.helper store Tip Windows and Linux clock issue: timedatectl set-local-rtc 1 --adjust-system-clock GitHub git remote git clone <link> # Copy repo into a new directory # Add remote to repository: git remote add origin <link> git push -u origin master Some alternatives to GitHub GitLab, BitBucket, Launchpad, Phabricator Markdown Markup language, easy to read Text file \u2192 Formatted document Widespread usag, e.g., blogs, forums, documentations, readme files, GitHub Markdown Cheatsheet Gyakorlat 0: GitHub repo l\u00e9trehoz\u00e1sa Inicializ\u00e1ljunk egy lok\u00e1lis git repo-t a ros-course package-ben. Regisztr\u00e1ljunk GitHub-ra, majd hozzunk l\u00e9tre egy private repo-t a ros_course package sz\u00e1m\u00e1ra. \u00c1ll\u00edtsuk be a local repo-ban a remote-ot, majd push-oljuk a package tartalm\u00e1t.","title":"7. Versioning, Git"},{"location":"07_git/#07-versioning-git","text":"Warning Test 2 on December 8.","title":"07. Versioning, Git"},{"location":"07_git/#lecture","text":"","title":"Lecture"},{"location":"07_git/#version-control-git","text":"Track changes in a set of files Coordinating work among developers Who made what changes and when Revert back at any time Local and remote repos Take snapshots of files by making a commit","title":"Version control, Git"},{"location":"07_git/#install","text":"sudo apt install git","title":"Install"},{"location":"07_git/#basic-commands","text":"git init # Initialize local git repo git add <file> # Add file/files to staging area git status # Check status of working tree and staging area git commit -m \"What I've done\" # Commit changes in index git push # Push to remote repository git pull # Pull latest changes from remote repo git branch <new_branch_name> git checkout <branch_name> git merge <branch_name> # Merge the branch into the current branch git config --global user.name \"Istvan Szabo\" git config --global user.email \"istvan.szabo@gmail.com\" Tip Store personal token: git config --global credential.helper store Tip Windows and Linux clock issue: timedatectl set-local-rtc 1 --adjust-system-clock","title":"Basic commands"},{"location":"07_git/#github","text":"git remote git clone <link> # Copy repo into a new directory # Add remote to repository: git remote add origin <link> git push -u origin master Some alternatives to GitHub GitLab, BitBucket, Launchpad, Phabricator","title":"GitHub"},{"location":"07_git/#markdown","text":"Markup language, easy to read Text file \u2192 Formatted document Widespread usag, e.g., blogs, forums, documentations, readme files, GitHub Markdown Cheatsheet","title":"Markdown"},{"location":"07_git/#gyakorlat","text":"","title":"Gyakorlat"},{"location":"07_git/#0-github-repo-letrehozasa","text":"Inicializ\u00e1ljunk egy lok\u00e1lis git repo-t a ros-course package-ben. Regisztr\u00e1ljunk GitHub-ra, majd hozzunk l\u00e9tre egy private repo-t a ros_course package sz\u00e1m\u00e1ra. \u00c1ll\u00edtsuk be a local repo-ban a remote-ot, majd push-oljuk a package tartalm\u00e1t.","title":"0: GitHub repo l\u00e9trehoz\u00e1sa"},{"location":"08_sensory_data/","text":"10. Szenzoros adatok gy\u0171jt\u00e9se \u00e9s feldolgoz\u00e1sa Gyakorlat Thing may change here... Ezt a gyakorlatot lehet, hogy le fogjuk cser\u00e9lni. 1: Leo rover Install\u00e1ljuk a Leo rover ROS package-eit: sudo apt update sudo apt install ros-noetic-leo* A http://wiki.ros.org/leo_gazebo le\u00edr\u00e1s seg\u00edts\u00e9g\u00e9vel ind\u00edtsuk el a gazebo szimul\u00e1tort a Mars landscape-pel. Ind\u00edtsunk teleop node-ot, \u00e9s mozgassuk meg a robotot. 2: K\u00e1v\u00e9 a Marson -- k\u00e9pek r\u00f6gz\u00edt\u00e9se Warning A Mars rover k\u00e9pet k\u00fcld\u00f6tt egy k\u00fcl\u00f6n\u00f6s, k\u00e1v\u00e9s b\u00f6gr\u00e9nek t\u0171n\u0151 t\u00e1rgyr\u00f3l! A feladat, hogy ford\u00edtsuk a rovert a b\u00f6gre fel\u00e9, majd k\u00f6zel\u00edts\u00fck meg, hogy r\u00e9szletesen megvizsg\u00e1lhassuk. Ind\u00edtsuk el a Gazebo-t: gazebo Az insert panelen keress\u00fck ki a googleresearch/models/cole_hardware_mug_classic_blue modellt, majd helyezz\u00fck el a szimul\u00e1ci\u00f3ban. Ez az\u00e9rt kell, hogy k\u00e9s\u0151bb meglegyen a b\u00f6gre modellje a f\u00e1ljrendszer\u00fcnkben. Z\u00e1rjuk be a Gazebo-t T\u00f6lts\u00fck le a leo_masryard_coffee.launch \u00e9s a marsyard_coffe.world f\u00e1jlokat, majd m\u00e1soljuk be rendre a catkin_ws/src/ros_course/launch \u00e9s catkin_ws/src/ros_course/worlds mapp\u00e1kba. A .world f\u00e1jlokban \u00edrjuk \u00e1t a /home/tamas/.ignition/fuel/fuel... el\u00e9r\u00e9si utakat (f\u00e1jlonk\u00e9nt 2x) a saj\u00e1tunkra. Ind\u00edtsuk el a szimul\u00e1tort: roslaunch ros_course leo_marsyard_coffee.launch Ind\u00edtsuk el a teleopot \u00e9s az rqt_image_view -t: rosrun leo_teleop key_teleop ``` ``` bash rosrun rqt_image_view rqt_image_view Tip Ha a szimul\u00e1tor futtat\u00e1sa t\u00fals\u00e1gosan megterhel\u0151 a PC sz\u00e1m\u00e1ra, dolgozhatunk a terrain n\u00e9lk\u00fcli leo_gazebo_coffee.launch \u00e9s gazebo_coffe.world f\u00e1jlokkal is. Ments\u00fcnk le egy-egy k\u00e9pet, amin l\u00e1that\u00f3, illetve nem l\u00e1that\u00f3 a k\u00e1v\u00e9s b\u00f6gre. 3: K\u00e1v\u00e9 a Marson -- offline k\u00e9pfeldolgoz\u00e1s \u00cdrjunk Python szkriptet, amely beolvassa \u00e9s megjelen\u00edti a lementett k\u00e9peket. Sz\u00edn alap\u00fa szegment\u00e1l\u00e1ssal (vagy b\u00e1rhogy m\u00e1shogy) szegment\u00e1ljuk a k\u00e1v\u00e9s b\u00f6gr\u00e9t. Hat\u00e1rozzuk meg a b\u00f6gre k\u00f6z\u00e9ppontj\u00e1t k\u00e9pi koordin\u00e1t\u00e1kban. A szegment\u00e1l\u00e1s zaja gondot okozhat, pr\u00f3b\u00e1ljuk meg lesz\u0171rni. 4: K\u00e1v\u00e9 a Marson -- online perception node Iratkozzunk fel a /camera/image_raw topicra, majd a cv.imshow() f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9val jelen\u00edts\u00fck meg a kapott k\u00e9peket. Dolgozzuk be a m\u0171k\u00f6d\u0151 computer vision algoritmusunkat egy ROS node-ba. Publik\u00e1ljuk \u00faj topicban a detekt\u00e1lt b\u00f6gre k\u00f6z\u00e9ppontj\u00e1nak k\u00e9pi koordin\u00e1t\u00e1t. Haszn\u00e1lhatjuk pl. az Int32MultiArray, Point2D t\u00edpusokat, vagy defini\u00e1lhatunk saj\u00e1tot (k\u00e9s\u0151bb sz\u00fcks\u00e9g lesz a b\u00f6gre m\u00e9ret\u00e9re is). B\u00f3nusz: publik\u00e1ljuk a maszkot \u00e9s a maszkolt k\u00e9pet egy-egy Image topicban 5: K\u00e1v\u00e9 a Marson -- operation logic node \u00cdrjunk \u00faj ROS node-ot, amely fogadja a perception node \u00fczeneteit, illetve k\u00e9pes a rover mozg\u00e1s\u00e1nak ir\u00e1ny\u00edt\u00e1s\u00e1ra. Forgassuk a rovert egy helyben, am\u00edg a b\u00f6gre a k\u00e9p k\u00f6zep\u00e9re nem ker\u00fcl. K\u00f6zel\u00edts\u00fck meg a b\u00f6gr\u00e9t annyira, hogy a l\u00e1tsz\u00f3lagos m\u00e9rete a k\u00e9p m\u00e9ret\u00e9nek 50%-\u00e1t el nem \u00e9ri. Ments\u00fcnk le k\u00e9pet a gyan\u00fas objektumr\u00f3l. 5+1: B\u00f3nusz N\u00e9zz\u00fcnk sz\u00e9t Gazebo-ban a beilleszthet\u0151 modellek k\u00f6z\u00f6tt ( insert panel) \u00e9s v\u00e1lasszunk egyet, amely valamilyen m\u00e1s m\u00f3dszerrel detekt\u00e1lhat\u00f3 a kamera k\u00e9p\u00e9n (pl. template matching). M\u00f3dos\u00edtsuk \u00fagy a node-okat, hogy ezt az objektumot k\u00f6zel\u00edtse meg a rover. Figyelem! Az \u00f3ra v\u00e9g\u00e9n a forr\u00e1sk\u00f3dokat mindenkinek fel kell t\u00f6lteni Moodle-re egy zip arch\u00edvumba csomagolva! Hasznos linkek http://wiki.ros.org/leo_gazebo http://wiki.ros.org/cv_bridge/Tutorials/ConvertingBetweenROSImagesAndOpenCVImagesPython https://realpython.com/python-opencv-color-spaces/ https://stackoverflow.com/questions/59164192/how-to-find-the-contour-of-a-blob-using-opencv-python","title":"10. Szenzoros adatok gy\u0171jt\u00e9se \u00e9s feldolgoz\u00e1sa"},{"location":"08_sensory_data/#10-szenzoros-adatok-gyujtese-es-feldolgozasa","text":"","title":"10. Szenzoros adatok gy\u0171jt\u00e9se \u00e9s feldolgoz\u00e1sa"},{"location":"08_sensory_data/#gyakorlat","text":"Thing may change here... Ezt a gyakorlatot lehet, hogy le fogjuk cser\u00e9lni.","title":"Gyakorlat"},{"location":"08_sensory_data/#1-leo-rover","text":"Install\u00e1ljuk a Leo rover ROS package-eit: sudo apt update sudo apt install ros-noetic-leo* A http://wiki.ros.org/leo_gazebo le\u00edr\u00e1s seg\u00edts\u00e9g\u00e9vel ind\u00edtsuk el a gazebo szimul\u00e1tort a Mars landscape-pel. Ind\u00edtsunk teleop node-ot, \u00e9s mozgassuk meg a robotot.","title":"1: Leo rover"},{"location":"08_sensory_data/#2-kave-a-marson-kepek-rogzitese","text":"Warning A Mars rover k\u00e9pet k\u00fcld\u00f6tt egy k\u00fcl\u00f6n\u00f6s, k\u00e1v\u00e9s b\u00f6gr\u00e9nek t\u0171n\u0151 t\u00e1rgyr\u00f3l! A feladat, hogy ford\u00edtsuk a rovert a b\u00f6gre fel\u00e9, majd k\u00f6zel\u00edts\u00fck meg, hogy r\u00e9szletesen megvizsg\u00e1lhassuk. Ind\u00edtsuk el a Gazebo-t: gazebo Az insert panelen keress\u00fck ki a googleresearch/models/cole_hardware_mug_classic_blue modellt, majd helyezz\u00fck el a szimul\u00e1ci\u00f3ban. Ez az\u00e9rt kell, hogy k\u00e9s\u0151bb meglegyen a b\u00f6gre modellje a f\u00e1ljrendszer\u00fcnkben. Z\u00e1rjuk be a Gazebo-t T\u00f6lts\u00fck le a leo_masryard_coffee.launch \u00e9s a marsyard_coffe.world f\u00e1jlokat, majd m\u00e1soljuk be rendre a catkin_ws/src/ros_course/launch \u00e9s catkin_ws/src/ros_course/worlds mapp\u00e1kba. A .world f\u00e1jlokban \u00edrjuk \u00e1t a /home/tamas/.ignition/fuel/fuel... el\u00e9r\u00e9si utakat (f\u00e1jlonk\u00e9nt 2x) a saj\u00e1tunkra. Ind\u00edtsuk el a szimul\u00e1tort: roslaunch ros_course leo_marsyard_coffee.launch Ind\u00edtsuk el a teleopot \u00e9s az rqt_image_view -t: rosrun leo_teleop key_teleop ``` ``` bash rosrun rqt_image_view rqt_image_view Tip Ha a szimul\u00e1tor futtat\u00e1sa t\u00fals\u00e1gosan megterhel\u0151 a PC sz\u00e1m\u00e1ra, dolgozhatunk a terrain n\u00e9lk\u00fcli leo_gazebo_coffee.launch \u00e9s gazebo_coffe.world f\u00e1jlokkal is. Ments\u00fcnk le egy-egy k\u00e9pet, amin l\u00e1that\u00f3, illetve nem l\u00e1that\u00f3 a k\u00e1v\u00e9s b\u00f6gre.","title":"2: K\u00e1v\u00e9 a Marson -- k\u00e9pek r\u00f6gz\u00edt\u00e9se"},{"location":"08_sensory_data/#3-kave-a-marson-offline-kepfeldolgozas","text":"\u00cdrjunk Python szkriptet, amely beolvassa \u00e9s megjelen\u00edti a lementett k\u00e9peket. Sz\u00edn alap\u00fa szegment\u00e1l\u00e1ssal (vagy b\u00e1rhogy m\u00e1shogy) szegment\u00e1ljuk a k\u00e1v\u00e9s b\u00f6gr\u00e9t. Hat\u00e1rozzuk meg a b\u00f6gre k\u00f6z\u00e9ppontj\u00e1t k\u00e9pi koordin\u00e1t\u00e1kban. A szegment\u00e1l\u00e1s zaja gondot okozhat, pr\u00f3b\u00e1ljuk meg lesz\u0171rni.","title":"3: K\u00e1v\u00e9 a Marson -- offline k\u00e9pfeldolgoz\u00e1s"},{"location":"08_sensory_data/#4-kave-a-marson-online-perception-node","text":"Iratkozzunk fel a /camera/image_raw topicra, majd a cv.imshow() f\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9val jelen\u00edts\u00fck meg a kapott k\u00e9peket. Dolgozzuk be a m\u0171k\u00f6d\u0151 computer vision algoritmusunkat egy ROS node-ba. Publik\u00e1ljuk \u00faj topicban a detekt\u00e1lt b\u00f6gre k\u00f6z\u00e9ppontj\u00e1nak k\u00e9pi koordin\u00e1t\u00e1t. Haszn\u00e1lhatjuk pl. az Int32MultiArray, Point2D t\u00edpusokat, vagy defini\u00e1lhatunk saj\u00e1tot (k\u00e9s\u0151bb sz\u00fcks\u00e9g lesz a b\u00f6gre m\u00e9ret\u00e9re is). B\u00f3nusz: publik\u00e1ljuk a maszkot \u00e9s a maszkolt k\u00e9pet egy-egy Image topicban","title":"4: K\u00e1v\u00e9 a Marson -- online perception node"},{"location":"08_sensory_data/#5-kave-a-marson-operation-logic-node","text":"\u00cdrjunk \u00faj ROS node-ot, amely fogadja a perception node \u00fczeneteit, illetve k\u00e9pes a rover mozg\u00e1s\u00e1nak ir\u00e1ny\u00edt\u00e1s\u00e1ra. Forgassuk a rovert egy helyben, am\u00edg a b\u00f6gre a k\u00e9p k\u00f6zep\u00e9re nem ker\u00fcl. K\u00f6zel\u00edts\u00fck meg a b\u00f6gr\u00e9t annyira, hogy a l\u00e1tsz\u00f3lagos m\u00e9rete a k\u00e9p m\u00e9ret\u00e9nek 50%-\u00e1t el nem \u00e9ri. Ments\u00fcnk le k\u00e9pet a gyan\u00fas objektumr\u00f3l.","title":"5: K\u00e1v\u00e9 a Marson -- operation logic node"},{"location":"08_sensory_data/#51-bonusz","text":"N\u00e9zz\u00fcnk sz\u00e9t Gazebo-ban a beilleszthet\u0151 modellek k\u00f6z\u00f6tt ( insert panel) \u00e9s v\u00e1lasszunk egyet, amely valamilyen m\u00e1s m\u00f3dszerrel detekt\u00e1lhat\u00f3 a kamera k\u00e9p\u00e9n (pl. template matching). M\u00f3dos\u00edtsuk \u00fagy a node-okat, hogy ezt az objektumot k\u00f6zel\u00edtse meg a rover. Figyelem! Az \u00f3ra v\u00e9g\u00e9n a forr\u00e1sk\u00f3dokat mindenkinek fel kell t\u00f6lteni Moodle-re egy zip arch\u00edvumba csomagolva!","title":"5+1: B\u00f3nusz"},{"location":"08_sensory_data/#hasznos-linkek","text":"http://wiki.ros.org/leo_gazebo http://wiki.ros.org/cv_bridge/Tutorials/ConvertingBetweenROSImagesAndOpenCVImagesPython https://realpython.com/python-opencv-color-spaces/ https://stackoverflow.com/questions/59164192/how-to-find-the-contour-of-a-blob-using-opencv-python","title":"Hasznos linkek"},{"location":"projects/","text":"Projects Challenge levels and grades Projects can be completed at three Challenge levels . The Challenge level determines the best grade that can be received to the project! Challenge level Best grade Basic 3 Advanced 4 Epic 5 Tip The projects are defined in a way that it is recommended to tart with the Basic level, and then gradually work towards Epic . The projects are graded based on the follwoing aspects: Proved to be the student's own work Running results valid output Usage of versioning, usage of GitHub/GitLab/other repository Grading: completeness of the soultion proper ROS communication proper structure of the program quality of implementation documentation quality Grading Personal attendance on the classes is mandatory (min 70%). To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again. Grade \\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\) Project topics 1. Mobil robot A. Playground Robot Gazebo install Setting up a robot simulation (Gazebo) B. TurtleBot4 TurtleBot4 Simulator Tutorial TurtleBot4 GUI Docs C. PlatypOUs (ROS 1) PlatypOUs GitHub D. Any mobile robot 1.1. Mobile robot obstacle avoidance Basic: SSimulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system to detect obstacle. Calculation and execution of a trajectory avoiding the obstacle in the simulator, using any sensor of the robot. Epic: Implementation and testing on the real robot/impress me! 1.2. Mobile robot path following Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system for path follwoing in the simulator, using any sensor of the robot (e.g., driving next to the wall with given distance using LIDAR). Epic: Implementation and testing on the real robot/impress me! 1.3. Mobile robot object follwoing Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system to detect an object and follow it in the simulator, using any sensor of the robot(e.g., visual servoing). Epic: Implementation and testing on the real robot/impress me! 1.4. Mobile robot action library Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS action library containing simple actions and their execution (e.g., push object, move to object, turn around). Epic: Implementation and testing on the real robot/impress me! 2. Quadcopter Gazebo install Setting up a robot simulation (Gazebo) ign gazebo -v 4 -r quadcopter.sdf Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: ROS system implementation to control velocity/position. Epic: Impress me! 3. Any Gazebo simulaion Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples Based on discussion. 4. Gazebo simulation creation Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples Based on discussion. 5. TurtleSim Turtlesim Tutorial Koch snowflake 5.1 Turtlesim Frakt\u00e1l/Sz\u00f6veg Basic: Implement a proportianl controller. Advanced: Draw fractal/text. Epic: Impress me! 6. DVRK Download and compile dVRK 2 Marker examples 6.1 DVRK Interactive Marker Graspable, movable marker for the DVRK simulator. 7. YouBot (Windows) YouBot controller GitHub 7.1. YouBot ROS integration Basic: YouBot repo build. Advanced: ROS wrapper/interface implementation, move the simulated arm in joint space from ROS. Epic: Implementation and testing on the real robot/impress me! X. Custom topic Based on discussion. Links Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples YouBot controller GitHub Download and compile dVRK 2 Marker examples Turtlesim Tutorial Koch snowflake","title":"Projects"},{"location":"projects/#projects","text":"","title":"Projects"},{"location":"projects/#challenge-levels-and-grades","text":"Projects can be completed at three Challenge levels . The Challenge level determines the best grade that can be received to the project! Challenge level Best grade Basic 3 Advanced 4 Epic 5 Tip The projects are defined in a way that it is recommended to tart with the Basic level, and then gradually work towards Epic . The projects are graded based on the follwoing aspects: Proved to be the student's own work Running results valid output Usage of versioning, usage of GitHub/GitLab/other repository Grading: completeness of the soultion proper ROS communication proper structure of the program quality of implementation documentation quality","title":"Challenge levels and grades"},{"location":"projects/#grading","text":"Personal attendance on the classes is mandatory (min 70%). To pass the course, Tests and the Project must be passed (grade 2). One of the Test can be taken again. Grade \\(Jegy = (Test1 + Test2 + 2 \\times Project) / 4\\)","title":"Grading"},{"location":"projects/#project-topics","text":"","title":"Project topics"},{"location":"projects/#1-mobil-robot","text":"","title":"1. Mobil robot"},{"location":"projects/#a-playground-robot","text":"Gazebo install Setting up a robot simulation (Gazebo)","title":"A. Playground Robot"},{"location":"projects/#b-turtlebot4","text":"TurtleBot4 Simulator Tutorial TurtleBot4 GUI Docs","title":"B. TurtleBot4"},{"location":"projects/#c-platypous-ros-1","text":"PlatypOUs GitHub","title":"C. PlatypOUs (ROS 1)"},{"location":"projects/#d-any-mobile-robot","text":"","title":"D. Any mobile robot"},{"location":"projects/#11-mobile-robot-obstacle-avoidance","text":"Basic: SSimulator setup, testing SLAM. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system to detect obstacle. Calculation and execution of a trajectory avoiding the obstacle in the simulator, using any sensor of the robot. Epic: Implementation and testing on the real robot/impress me!","title":"1.1. Mobile robot obstacle avoidance"},{"location":"projects/#12-mobile-robot-path-following","text":"Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system for path follwoing in the simulator, using any sensor of the robot (e.g., driving next to the wall with given distance using LIDAR). Epic: Implementation and testing on the real robot/impress me!","title":"1.2. Mobile robot path following"},{"location":"projects/#13-mobile-robot-object-follwoing","text":"Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS system to detect an object and follow it in the simulator, using any sensor of the robot(e.g., visual servoing). Epic: Implementation and testing on the real robot/impress me!","title":"1.3. Mobile robot object follwoing"},{"location":"projects/#14-mobile-robot-action-library","text":"Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: Implementation of a ROS action library containing simple actions and their execution (e.g., push object, move to object, turn around). Epic: Implementation and testing on the real robot/impress me!","title":"1.4. Mobile robot action library"},{"location":"projects/#2-quadcopter","text":"Gazebo install Setting up a robot simulation (Gazebo) ign gazebo -v 4 -r quadcopter.sdf Basic: Simulator setup. Implementation of ROS node(s) to read the sensor data and move the robot. Advanced: ROS system implementation to control velocity/position. Epic: Impress me!","title":"2. Quadcopter"},{"location":"projects/#3-any-gazebo-simulaion","text":"Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples Based on discussion.","title":"3. Any Gazebo simulaion"},{"location":"projects/#4-gazebo-simulation-creation","text":"Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples Based on discussion.","title":"4. Gazebo simulation creation"},{"location":"projects/#5-turtlesim","text":"Turtlesim Tutorial Koch snowflake","title":"5. TurtleSim"},{"location":"projects/#51-turtlesim-fraktalszoveg","text":"Basic: Implement a proportianl controller. Advanced: Draw fractal/text. Epic: Impress me!","title":"5.1 Turtlesim Frakt\u00e1l/Sz\u00f6veg"},{"location":"projects/#6-dvrk","text":"Download and compile dVRK 2 Marker examples","title":"6. DVRK"},{"location":"projects/#61-dvrk-interactive-marker","text":"Graspable, movable marker for the DVRK simulator.","title":"6.1 DVRK Interactive Marker"},{"location":"projects/#7-youbot-windows","text":"YouBot controller GitHub","title":"7. YouBot (Windows)"},{"location":"projects/#71-youbot-ros-integration","text":"Basic: YouBot repo build. Advanced: ROS wrapper/interface implementation, move the simulated arm in joint space from ROS. Epic: Implementation and testing on the real robot/impress me!","title":"7.1. YouBot ROS integration"},{"location":"projects/#x-custom-topic","text":"Based on discussion.","title":"X. Custom topic"},{"location":"projects/#links","text":"Gazebo install Setting up a robot simulation (Gazebo) Gazebo World Examples YouBot controller GitHub Download and compile dVRK 2 Marker examples Turtlesim Tutorial Koch snowflake","title":"Links"}]}